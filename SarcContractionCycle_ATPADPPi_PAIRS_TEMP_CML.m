%{
SarcContractionCycle.m

Created: 08/22/2020
Last Updated: 05/09/2023

written by Andrew Schmidt
Cardiomyocyte Laboratory
Henry Samueli School of Engineering
University of California, Irvine, Irvine, CA 92697

The purpose of this code is to simulate actin-myosin contraction (ATPase)
cycle of myosin heads in a simple half-sarcomere model.


Input: 
        Automatic input of:
        1. 
        
Output: Force borne through the half-sarcomere, ATPase rate, among other outputs

%}
clear;
close all;

%% Generate Constants
%{
%const_gen();   
%The constants for the half sarcomere contraction simulation are generated by the const_gen() function
disp('Please Pick a Parameter File...');
[file, path] = uigetfile('*.mat', 'Select Parameter File...', 'C:\Users\andre\OneDrive\Documents\GRAD SCHOOL\Grosberg\3_Summer 2020\Modeling O2-Contraction\Matlab - Modeling O2-Contraction');
filename = [path file];
load(filename);
filename_beta = [filename];


%% Establish Initial Geometry
disp('Please Pick an Initial Geometry File...');
[file2, path2] = uigetfile('*.mat', 'Select Geometry File...', 'C:\Users\andre\OneDrive\Documents\GRAD SCHOOL\Grosberg\3_Summer 2020\Modeling O2-Contraction\Matlab - Modeling O2-Contraction');
filename2 = [path2 file2];
load(filename2);

path2_str = path2;
filename1_str = [path2_str, filename_beta];
filename2_str = [filename2];
%}

% % % % % % % %filename1_str = 'C:\Users\Tessa\Desktop\Andrew\Matlab_SarcModel\anoCaconst_gen.mat';
% % % % % % % filename1_str = 'F:\Andrew\Matlab_SarcModel\anoCaconst_gen.mat';

load('C:\Users\andre\OneDrive\Documents\GRAD SCHOOL\Grosberg\8_Fall_2021\Sarcomere Model Paper\Const_Test_Files\noCaconst_gen.mat');
load('C:\Users\andre\OneDrive\Documents\GRAD SCHOOL\Grosberg\8_Fall_2021\Sarcomere Model Paper\Const_Test_Files\ainitial_geometry_testcase=8.2416_a_nodes=24,m_nodes=16,a0=1.23e-08,m0=1.43e-08,xb0=1e-08,xf0=1e-07,t_end=6,dt=0.001.mat');
filename1_str = 'C:\Users\andre\OneDrive\Documents\GRAD SCHOOL\Grosberg\8_Fall_2021\Sarcomere Model Paper\Const_Test_Files\noCaconst_gen.mat';
filename2_str = 'C:\Users\andre\OneDrive\Documents\GRAD SCHOOL\Grosberg\8_Fall_2021\Sarcomere Model Paper\Const_Test_Files\ainitial_geometry_testcase=8.2416_a_nodes=24,m_nodes=16,a0=1.23e-08,m0=1.43e-08,xb0=1e-08,xf0=1e-07,t_end=6,dt=0.001.mat';


fprintf('\n'); 

%% Storage for values taken across simulations

% SUM OF TOTAL FORCE OUTPUT ACROSS SIMULATIONS
F_outputTotalSims = zeros(1, 1e8); %1e8 > total simulation run time/discretized timestep value

% SUM OF ALL ATP CONSUMPTION ACROSS SIMULATIONS
ATPase_trackerTotalSims = zeros(1, 1e8); %1e8 > total simulation run time/discretized timestep value

% CONTINUOUS +- STD_MULT*STD TAU STORAGE ACROSS SIMULATIONS
startNextSim_from_GeomPrev = false; %Go through and delete where this is relevant because it is breaking other stuff, so keep in temp SarcContr32.2
% DELETE t_ab_intervals_long_TotalSims = [];

%% Simulation External Loop - Run Loops of Sets of n_sim Simulations to Decrease Overall Runtime
totalSimCounter = 0;
n_extLoop = 1; %multiply this by n_sim to get total number of simulations
n_sim = 1; %number of internal simulations
extLoopTotTime = 0;

for extLoopCounter = 1:n_extLoop
clearvars -except filename1_str filename2_str F_outputTotalSims ATPase_trackerTotalSims totalSimCounter ...
            n_extLoop t_end_true_store t_end_true_min t_EaSim_store dt_EaSim_store extLoopTotTime n_sim F_discrEaSim_store F_outputRawEaSim_store ATP_discr_store F_df_StorePerSim ...
            plat_ATPConsPerSim ATPase_discr_cum_store ATPase_tracker_plot_eaSim_store Fop_discr_store ATPase_discr_store ATP_Cons_movAvg_eaSim_store t_ab_int_df F_ab_int_df Epot_discr_store Mline_discr_store ...
            Epot_IntSprings_Mean_store Epot_IntSprings_Std_store Epot_ExtSpring_Mean_store Epot_ExtSpring_Std_store t_ab_int_long_df ...
            startNextSim_from_GeomPrev t_ab_intervals_long_TotalSims N_locInitial_from_GeomPrev N_statesInitial_from_GeomPrev xb_conn_bound_from_GeomPrev
load(filename1_str);
load(filename2_str);


%% Setting Applied Force and Duration Profile

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %External Force Application by moving xf
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %%{
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %Set xf0 to be very large
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % xf0_long = 10e-6; %10 microns
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % xf0 = xf0_long;
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % xf = N_locations(1, tot_nodes) + xf0;
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %provide t_appforce and t_remove force (in seconds)
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % t_appforce = 0; %1.5; %1.5; %1e-4; %250e-3; %100e-3;
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % t_removeforce = 0; %4.5;  %4.5; %1; %5250e-3; %10000e-3; %1250e-3; %150e-3; 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % F_appforce = 5e-12; % Applied force, tension, in N (20 pN in N)
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %Implement "steady/constant" force via a very large xf_0
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % kF_longxf0 = -F_appforce/(N_locations(1, tot_nodes) - xf0); 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % kF = kF_longxf0;

% Outside Spring Stiffness
% kF = 10; % External spring stiffness for isometric contraction
           % Can be used with more elastic ka and km to see more wiggling of nodes
%Implement temporary change to external spring stiffness
% kF = 1e-4; %Standard: 0.5e-3

% % % % % % % % % %Testcase 1, kATP0=1e-1, 45pN to get p31 = 0.4 with dt = 1e-3; 
% % % % % % % % % kextEff = 1/((1/k_titin) + (m_nodes/km) + (1/kF));
% % % % % % % % % xf_new = N_locations(1, tot_nodes) + xf0 + F_appforce/kextEff;
% % % % % % % % % % xf_new = N_locations(1, tot_nodes) + appforce/kF + xf0; %generates the new location of the outside anchor for the external spring
% % % % % % % % % %Include external force as a vector
% % % % % % % % % % appF_vec = [0, t_appforce, t_removeforce];
% % % % % % % % % % appF_vec_ind = 1;
% % % % % % % % % % F_app_vec = %hard to do as time vs. timesteps
% % % % % % % % % 
% % % % % % % % % %Apply Calcium-dependent regulation of actin availability
% % % % % % % % % % t_Ca = 3000; % tot_timesteps+1; %Never add Ca2+ to the system
% % % % % % % % % % %}

%% Define mechanical model matrices P=K^(-1)V

%Constructing K and V matrices
%For when a_z is fixed, m_M unknown, F represented by external spring

% % % % % % %Are you going to deactivate a portion of the myosin = are you going to have longer springs for the initial actin and
% % % % % % %final myosin springs? i.e. a0_long and m0_long
% % % % % % m_deactivation = false;
% % % % % % % m_deactivation_count = 0;

% % % % % % %Manual changes to spring constants:
% % % % % % %https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2896680/
% % % % % % % km = 6060e-2; %6060e-2; %252e-3; %0.5e-3; %6060e-3; %spring constant for myosin filament; 6060 pN/nm in N/m
% % % % % % % ka = 5230e-2; %5230e-2; %125e-3; %5230e-3; %spring constant for actin filament; 5230 pN/nm in N/m
% % % % % % % kxb = 3e-2; %3e-3;
% % % % % % % k_titin = 2; %spring constant for titin; 10 pN/nm in N/m
% % % % % % % kF = 0.5e-6;
% % % % % % % springs = [n_sim, ka, km, kxb, k_titin, kF];
% % % % % % % d_ps = 10e-9; %10nm


%Initialize K and V matrices
K = zeros(tot_nodes-1, tot_nodes-1);
V = zeros(tot_nodes-1, 1);

%Initial actin node (a1)
V(1) = -ka*a_z;

% % % % % % % % % % % % % % if m_deactivation == true
% % % % % % % % % % % % % %     V(1) = -ka*a_z + ka*a0 - ka*a0_long; %initial actin node
% % % % % % % % % % % % % % end

%M-line node
K(tot_nodes-1, tot_nodes-2:tot_nodes-1) = [km, -km-kF]; %titin connects Z-line to m1 node
V(tot_nodes-1) = - km*m0 - kF*(xf - xf0); %titin connects Z-line to m1 node

% % % % % % % % % % % % % if m_deactivation == true
% % % % % % % % % % % % %     V(tot_nodes-2) = -km*m0 + km*m0_long;
% % % % % % % % % % % % %     V(tot_nodes-1) = -km*m0_long - kF*(xf - xf0); %M-line node
% % % % % % % % % % % % % end

%edge internal actin node (only occurs when there is more than 1 a_node)
if a_nodes > 1
    K(a_nodes, a_nodes-1:a_nodes) = [ka, -ka];
end
% V(a_nodes) = V(a_nodes) - ka*a0;
V(a_nodes) = - ka*a0;

%edge internal myosin node
%K(a_nodes+1, a_nodes+1:a_nodes+2) = [-km, km]; %titin connects Z-line to M-line
K(a_nodes+1, a_nodes+1:a_nodes+2) = [-km-k_titin, km]; %titin connects Z-line to m1 node
%V(a_nodes+1) = km*m0; %titin connects Z-line to M-line
V(a_nodes+1) = km*m0 - k_titin*(a_z+titin0); %titin connects Z-line to m1 node

%internal actin nodes
K(1, 1:2) = [-2*ka, ka];
if a_nodes == 1
    K(1, 1:2) = [-ka, 0];
end
if a_nodes > 1
    for i = 2:a_nodes-1
        K(i, (i-1):(i+1)) = [ka, -2*ka, ka];
    end
end

%internal myosin nodes
for i = (a_nodes+2):(tot_nodes-2)
    K(i, (i-1):(i+1)) = [km, -2*km, km];
end

%Create matrix for resetting K matrix within timestep
K_reset = K;
K_reset_short = K; %when mM - aZ < titin_0, k_titin = 0
K_reset_short(a_nodes+1, a_nodes+1:a_nodes+2) = [-km, km]; %titin connects Z-line to m1 node 

%Create matrix for updating V matrix within timestep
V_xb_mult = zeros(tot_nodes-1, 1);
V_xb_mult(1:a_nodes) = 1;
V_xb_mult(a_nodes+1:tot_nodes-2) = -1;

%Create a V_reset vector to reset V to before adding in XB terms
V_reset = V;
V_reset_short = V; %when mM - aZ < titin_0, k_titin = 0
V_reset_short(a_nodes+1) = km*m0; %titin connects Z-line to m1 node


%% Contraction cycle simulation
%{
Definitions of XB states:
State 1: unbound - myosin is unbound from actin
State 2: bound, pre-power stroke - low force-bearing
State 3: bound, post-power stroke - high force-bearing
Definitions of actin states:
State -1: unavailable (no Ca2+ present)
State 0: unbound
State 1: bound
%}
    
%Do you want to plot the results?
create_plots = true; %Set to true when want to plot outputs
create_StTraj_plot = false; %State Trajectories plot
create_Epot_plot = true; %Epot of ext spring/(ATP/s) 2/23/2022
create_Fxb_plot = false; 

%Do you want to save the workspace?
save_workspace = false;

%Track duration code is running, tracking time to complete simulations, start timer
display_code_runtime = true; %Set to true when want to display code runtime periodically during simulation and after each simulation is complete
timerVal_sim = tic;

%Set max size of timestep
dt_max = dt; %1e-3 %maximum dt value, set by initial_geometry

%% Change [ATP] and [ADP][Pi] along a diagonal such that the ratio between the two values varies  

%%{

% ADP = [3.00E-16 3.00E-14 3.00E-12 3.00E-10	3.00E-08 3.00E-06	3.00E-05	3.00E-04	3.00E-03	3.00E-02	3.00E-01	3.00E+00	3.00E+01	3.00E+02	3.00E+03	3.00E+04]; %in M;
ADP = [3.00E-03	3.00E-02];
ADPPi = ADP.*conc_P; %[Pi] is held constant at 3mM
logADPPi = log10(ADPPi);

% ATP = [5.00E-16 5.00E-14 5.00E-12	5.00E-11	5.00E-10	5.00E-09	5.00E-08	5.00E-07	5.00E-06	5.00E-05	5.00E-04	5.00E-03	5.00E-02	5.00E-01	5.00E+00	5.00E+01]; %in M; 
ATP = [5.00E-04	5.00E-03];
logATP = log10(ATP);

%Standard Condtions?
stdcond = true;
if stdcond == true
    ADP = 0.03e-3;
    ATP = 5e-3;
    ADPPi = ADP.*(3e-3);
end

[y_ADPPi, x_ATP] = meshgrid(ADPPi, ATP);
z_ATPoverADPPi = x_ATP./y_ADPPi;

% StandardATPADPPi = [5, 0.03, 3]; %in mM ATP, ADP, Pi

% % % % % % % % % % % % % % % % % [logx_ADPPi, logy_ATP] = meshgrid(log10(ADPPi), log10(ATP));
% % % % % % % % % % % % % % % % 
% % % % % % % % % % % % % % % % % logADPPi = [-4.04575749056068,-3.04575749056068,-2.04575749056068,-1.34678748622466,-1.04575749056068,-0.744727494896694,-0.346787486224656,-0.0457574905606752,0.954242509439325,2.95424250943932,4.95424250943933,6.95424250943933,8.95424250943933,10.9542425094393,12.9542425094393,18.9542425094393];
% % % % % % % % % % % % % % % % % logATP = [-4.30102999566398,-3.30102999566398,-2.30102999566398,-1.30102999566398,-0.301029995663981,0.397940008672038,0.698970004336019,1.39794000867204,2.69897000433602,4.69897000433602,6.69897000433602,8.69897000433602,10.6989700043360,12.6989700043360,15.6989700043360,20.6989700043360];

%log of the above vectors
log_z_ADPPiATP = log10(z_ATPoverADPPi);
log_y_ADPPiATP = log10(y_ADPPi);
log_x_ADPPiATP = log10(x_ATP);

%8/30/2022
ADPPi_flip = flip(ADPPi);
for ATP_i = 1:length(x_ATP) 
    ADPPi_ATP_pairs(ATP_i, 1) = ATP(ATP_i); %y_ADPPi(ATP_i, ADP_i(ATP_i));
    ADPPi_ATP_pairs(ATP_i, 2) = ADPPi_flip(ATP_i); %x_ATP(ATP_i, ADP_i(ATP_i));
end

ratio_ADPPioverATP_pairs = ADPPi_ATP_pairs(:, 1)./ADPPi_ATP_pairs(:, 2); %Ratios for f(R1), f(R2), etc calculations
log_ratio_ADPPioverATP_pairs = log10(ratio_ADPPioverATP_pairs);
log_ADPPi_ATP_pairs = log10(ADPPi_ATP_pairs);
fullLog_ATP_ADPPi_Ratio_DataTable = [log_ADPPi_ATP_pairs, log_ratio_ADPPioverATP_pairs];

% Put into vectors compatible with current code
conc_i_D_end = length(y_ADPPi); 
conc_i_T_end = length(x_ATP); 
conc_ADP_vec = ADP;
conc_ATP_vec = ATP;
conc_ADPPi_vec = ADPPi;

% TvDsavefilename = 'TvDvalues_AllConcs_testcase8.2416_8-30-22_evenwiderbounds.mat';
TvDsavefilename = 'TvDvalues_AllConcs_testcase8.2416_04-30-23'; %_FROMcfADP=10_cfATP=16_otherwiderbounds.mat';

%}

%% Create storage matrix for outputs. Cycle times in (:,:,1), Force output in (:,:,2), K23 in (:,:,3), k31 in (:,:,4)
TvD_store = NaN(conc_i_T_end, conc_i_D_end, 8);   
excel_op_counter = 0;


%% Begin Simulation
for cf_ADP = 1:conc_i_D_end
for cf_ATP = 1:conc_i_T_end
%     cf_ATP = cf_ATP+1;
excel_op_counter = excel_op_counter + 1;

%What is chemical potential energy of hydrolysis?
% Echempot = 1/B*log((conc_ADP_vec(cf_ADP)*conc_P)/conc_ATP_vec(cf_ADP));

for sim_counter = 1:n_sim
%Shuffle the random number generator
rng('shuffle');

% Reset N_locations
N_locations(2:tot_timesteps, :) = 0;

% Track total number of sims
n_totalsim = n_extLoop*n_sim;
totalSimCounter = totalSimCounter + 1;

    
% Create state-tracking arrays
N_states = zeros(size(N_locations)); %Array of states of actin and myosin nodes (see below for state definitions)
N_states(1, 2:a_nodes+1) = -1; %initialize "time = 0" actin as unavailable (-1)
N_states(1, a_nodes+2:tot_nodes-1) = 1; %initialize "time = 0" states for myosin (1) 
ATPase_tracker = zeros(1, tot_timesteps); %track ATPase activity whenever ATP is hydrolyzed
F_output = zeros(1, tot_timesteps); %track F_output on the external spring at the end of each timestep
F_output_mline = zeros(1, tot_timesteps); %track F_output on the final spring of the thick filament
strain_hs = zeros(1, tot_timesteps); %track the strain on the half sarcomere (from az to mM) at the end of each timestep
E_potential_ext = zeros(tot_timesteps, 1);
%xb_state = ones(m_nodes, 1); %all xb start in state 1 - unbound, starting at m1 (no M-line)
%a_state = zeros(a_nodes, 1); %keep track of which actin nodes are occupied (1), all start unoccupied (0), starting at a1
m_res_tracker = zeros(m_nodes, 3); %keep track of how many times a myosin enters a specific state
m_res_tracker(:, 1) = 1;
m_res_initial = 1:6:m_nodes*6;
m_res_remaining = [2:6];
if m_nodes >  1
    for m = 1:m_nodes
       m_res_remaining = [m_res_remaining, [(m-1)*6+2:1:(m-1)*6+6]];
    end
end
clear m_res_times
m_res_times(m_res_initial, 1) = t_Ca; %PICKUP double check this is not t_Ca+1
m_res_times(m_res_remaining, 1) = NaN;
dt_counter = 0; %Track number of double transitions

% State-tracking arrays, but only for productive timesteps
% N_states_new = NaN(
% N_states_dynamic

%Track XB locations and place into xb_conn_all matrix added to K at the end of each time step
% xb_conn_all = zeros(3, m_nodes); %matrix to contain potential XBs
% xb_conn_all(2, 1:m_nodes) = [a_nodes+2:tot_nodes-1]; %second row contains all possible XB indices (m1 - mn), first row is index of nearest actin
%Fill 3rd row (displacement to nearest actin) inside for loop

%Track XB locations of only bound XBs and actin nodes they are bound to,
%initialize as empty, will be updated after first timestep
xb_conn_bound = [];
clear xb_conn_comb;
% clear xb_conn_free;
% clear a_free_indices;
xb_conn_bound_store = cell(tot_timesteps, 1);
% xb_conn_free_store = cell(tot_timesteps, 1);

%Create matrix to store updates for K matrix
xb_conn_K = zeros(2, m_nodes); %matrix to contain potential XBs
xb_conn_K(2, 1:m_nodes) = [a_nodes+2:tot_nodes-1]; %second row contains all possible XB indices (m1 - mn), first row is (0) when unbound or (an = actin index) when bound
xb_mat = zeros(size(K));
V_xb = zeros(tot_nodes-1, 1);
colorcode = {'r*', 'ro', 'r^';'b*', 'bo', 'b^' ; 'k*', 'ko', 'k^'}; %[1,1 1,2 1,3 ; 2,1 2,2 2,3 ; 3,1 3,2 3,3]
ones_m_nodes = ones(1, m_nodes);

%Pre-allocate Storage Arrays 
% a_state_store = NaN(tot_timesteps, a_nodes);
ATPase_tracker_plot = zeros(1, tot_timesteps);
avg_res_times = NaN(m_nodes, 3);
ATPase_ea_m = zeros(1, m_nodes);
% F_store = NaN(tot_timesteps, tot_nodes); %maybe tot_timesteps+1
% K_store = NaN(size(K, 1), size(K, 2), tot_timesteps);
% prob_store = NaN(tot_timesteps, 16);
% prob_store_mult = zeros(tot_timesteps*(m_nodes+1)+m_nodes, 10);
t = NaN(1, tot_timesteps);
% V_store = NaN(size(V, 1), size(V, 2), tot_timesteps);
work_store = zeros(tot_timesteps, 1); %track mechanical work done by the half sarcomere
% work_per_ATP = zeros(tot_timesteps, 2); %track mechanical work done per ATP by the half sarcomere at each time
xb_conn_comb_store = zeros(tot_timesteps*4+2, (1+2*m_nodes)); %check second dimension later
% xb_conn_K_store = NaN(3, m_nodes, tot_timesteps);
% xb_mat_store = NaN(size(K, 1), size(K, 2), 5, tot_timesteps);
% xb_prob_store = NaN(tot_timesteps, m_nodes);
% xb_state_store = NaN(tot_timesteps, m_nodes); %maybe tot_timesteps+1
xb_trans_store = NaN(tot_timesteps-1, m_nodes);
rates_123_store = NaN(tot_timesteps-1, 7); %6 rates k12 to k31 + state the myosin is in
FracXbBound = NaN(tot_timesteps-1, 1); %fraction of cross bridges bound at the end of the timestep
clear prob_store_mult2

%Variable timestep variables:
%Used to track any new values associated with having a timestep of variable size
rates_summed = NaN(m_nodes, 1); %stores the sum of the relevant rates for each iteration -> rows: myosin number, value: sum of relevant rates e.g. state 2 -> k21 + k23
dt_store = NaN(1, tot_timesteps-1); %store the value of dt for each iteration of the contraction cycle
prob_summed_max = 0.5; %0.315 %0.5 %0.1 %The maximum sum of probabilities relevant to the potential state changes of a single myosin for each iteration
                       %e.g. a myosin in state 2 would mean the timestep was of size dt' such that (k23 + k21)*dt' < 1 or 0.5 etc
prob_sum_max_exact = 0.9; %0.1; %same as above, but for determining dt's that lead to a sum of probabilities exactly prob_summed_max_exact
% For simulating step function for ATPase
ATPase_step = 1;
ATPase_stepfunc = false;
ATPase_interp = false;
ATPase_RMSE_weighted = true; %ATPase_interp and ATPase_weighted cannot both be true, if interp is true, then weighted will not run
fix_ATPaselr_int = false;
ATPase_CycleThru = false; %cycle through the states for 3.11 case only. Preserves timestep size for standard constants
correlation_func = false;
save_data_for_corr_func = false; %do you want to save the necessary force, timestep, and time data for the correlation function and plots
if startNextSim_from_GeomPrev == true && totalSimCounter ~= 1
    N_locations(1, :) = N_locInitial_from_GeomPrev;
    N_states(1, :) = N_statesInitial_from_GeomPrev;
    xb_conn_bound = xb_conn_bound_from_GeomPrev;
end



%Testcase: Remove ATP after a few time steps by forcing ATP concentration to basically 0 (cannot be zero because of logarithms in rate equations)
%%{
removeATP = false;
ind_removeATP = 100;
removeATP_counter = 0;
%}


t_index = 1; %initialize t_index
t(t_index) = 0; %start time tracking array at zero

% Track duration code is running, tracking periods within the contraction cycle, start timer
timerVal_cycle = tic;

while t_index < tot_timesteps
    % while t(t_index) < t_end

%for t_index = 1:tot_timesteps
%     t(t_index) = dt*(t_index-1); %keep track of current time

%Testcase: Remove ATP after a few timesteps
if removeATP == true
    removeATP_counter = removeATP_counter + 1;
    if removeATP_counter > ind_removeATP
        conc_ATP_vec(cf_ATP) = 1e-12; %1 picomolar
    end    
end

    % Create arrays to store current state of actin nodes and myosin nodes
    xb_state = N_states(t_index, a_nodes+2:tot_nodes-1); %track myosin states during each timestep: 1 - unbound, 2 - pre-ps, 3 - post-ps
    a_state = N_states(t_index, 2:a_nodes+1); %track actin states during each timestep: 0 - available, 1 - occupied
    
    %Implement calcium regulation of actin availability
    t_Ca_counter = t_Ca_counter + 1;
%     if (t_Ca_counter > t_Ca) && (Ca_reg == 0)
    if (t_Ca_counter > t_Ca) && (Ca_reg == 0)
        Ca_reg = 1;
        N_states(t_index, 2:a_nodes+1) = 0;
%         conc_Ca = 1; %Max contraction in some experiments occurs at pCa = 4.3 or ~2e4 M; relaxation at pCa = 9
%         conc_Ca_MaxContraction = 4.3; %pCa of max contraction (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2943343/)
%         prob_avail = conc_Ca/conc_Ca_MaxContraction; %Some function converting calcium concentration to the the availability of actin nodes
%         avail_indices = randperm(a_nodes, round(prob_avail*a_nodes)+1); %will have to implement check that this does not include indices of bound actin (1)
%         N_states(t_index, avail_indices) = 0; %Set certain actin nodes to available based on Ca concentration
    end
 
if t_Ca_counter > t_Ca %PICKUP: may have to update this to be t(t_Ca_counter) to make it more accurate since dt is variable. t_Ca is already in seconds
if dt_counter == 0 %If there was a double transition, don't need to redo the below; continue at creation of "xb_prob"
    
%Create new vectors to implement the deactivation of actin and myosin
%indices for active actin and myosin based on adjustments from an 8.8050 testcase with 151.6 nm between final actin and M-line
% if m_deactivation == true && m_deactivation_count == 0
%     m_deactivation_count = 1;
%     m_cond = 1; % 1 = 8.96, 2 = 8.2516, 3 = 8.4025, 4 = 8.6440
%     a_active_vec = [31, 39; 26, 50; 17, 56; 11, 74]; %active actin for 6 myosin, 16 myosin, 25 myosin, 40 myosin
%     m_active_vec = [6, 16, 25, 40];
%     m_deact = [a_nodes+2+m_active_vec(m_cond):1:tot_nodes-1];
%     a_deact = [2:1:a_active_vec(m_cond, 1), a_active_vec(m_cond, 2):1:a_nodes+1];
%     N_states(t_index, m_deact) = 0;
%     N_states(t_index, a_deact) = -1;
%     %Change remaining variables to compensate for deactivation of some myosin
%     ones_m_nodes = ones(1, m_active_vec(m_cond));
% %     xb_state = N_states(t_index, a_nodes+2:tot_nodes-1); %track myosin states during each timestep: 1 - unbound, 2 - pre-ps, 3 - post-ps
% %     a_state = N_states(t_index, 2:a_nodes+1); %track actin states during each timestep: 0 - available, 1 - occupied
% %     m_nodes = m_active_vec(m_cond);
% %     a_nodes = a_active_vec(m_cond, 2) - a_active_vec(m_cond, 1) + 1;
% end
    
    %Create arrays of actin and myosin nodes that are available for binding
    %transitions; for actin (0) and for myosin (1->2 or 1->3 transitions)
    a_free_indices = find(N_states(t_index, 2:a_nodes+1) == 0)+1; %indices of available actin nodes (state 0); +1 accounts for Z-line
    m_free_indices = find(N_states(t_index, a_nodes+2:tot_nodes-1) == 1)+(a_nodes+1); %indices of state 1 myosin nodes; +1 accounts for Z-line
    a_free_loc = N_locations(t_index, a_free_indices); %meter locations of available actin nodes (state 0)
    m_free_loc = N_locations(t_index, m_free_indices); %meter locations of unbound myosin nodes (state 1)
    
    %Create array of distances between nodes
    a_free2 = repmat(a_free_loc, size(m_free_indices, 2), 1); %create matrix of available actin node locations in rows a1, a2, ... (no z-line, z-line cannot form xb)
    m_free2 = repmat(m_free_loc.', 1, size(a_free_indices, 2)); %create matrix of state 1 myosin node locations in columns m1, m2, ... (no m-line, m-line cannot form xb)
%     a_m_free_disp = abs(m_free2 - a_free2 - xb0); %matrix of absolute value of displacement (meter) distances between all nodes with myosin node indices as row labels and actin node indices as columns
    a_m_free_disp = m_free2 - a_free2 - xb0; %matrix of displacement (meter) distances between all nodes with myosin node indices as row labels and actin node indices as columns
    
    rowdist = ones(1,length(m_free_loc));
    a_m_free_cell_disp = mat2cell(a_m_free_disp, rowdist);
%     a_m_free_cell_disp = mat2cell(abs(a_m_free_disp), rowdist); % add abs here??
            
    %Check to ensure "nearest actin" does not crossover existing XB
    %a_bound = N_states(t_index, 2:a_nodes+1) == 1;
    xb_crossover = zeros(size(a_m_free_disp));
    if size(xb_conn_bound, 2) > 0
        for k = 1: size(m_free_indices, 2)
            for i = 1:size(xb_conn_bound, 2)
                    m_i = xb_conn_bound(2,i);
                    a_j = xb_conn_bound(1,i);
                    m_k = m_free_indices(k);
                for l = 1:size(a_free_indices, 2)
                     a_l = a_free_indices(l);
                     if (m_k > m_i) && (a_j > a_l)
                        xb_crossover((m_free_indices == m_k), (a_free_indices == a_l)) = NaN;
                    elseif (m_k < m_i) && (a_j < a_l)
                        xb_crossover((m_free_indices == m_k), (a_free_indices == a_l)) = NaN;
                    end
                end
            end
        end
    end
%     a_m_free_disp = a_m_free_disp + xb_crossover;
    
    %Find minimal x-displacement for each myosin node to the nearest actin node (xb_conn_free(2,:), 
    %and save that to xb_conn_free(3,:) and the actin index to xb_conn_free(1,:)
    [min_disp, index] = min(abs(a_m_free_disp), [], 2); %minimum will store the minimum of each row; index will store the index (in a_free_indices) of closest actin , both in column vectors
    disp_signs = a_m_free_disp < 0; %1 = (-), 0 = (+) %Track which values within the min_disp matrix are negative (<0)
    disp_rows = 1:1:size(disp_signs, 1); %Create an array that is 1 -> # of free myosin (increment by 1)
    if(size(a_free_indices) > 0)
        disp_signs_pos = sub2ind(size(disp_signs), disp_rows, index.'); %row vector of linear indices of minimum of each row of min_disp
    else
        disp_signs_pos = [];
    end
    % Create ds_mult to multiply min_disp by to get the original signs of the displacements
    ds_mult = disp_signs(disp_signs_pos)*-1; %convert logical array to numeric with -1 where 1 was (should be a row vector if a_m_free_disp is a matrix and not column vector i.e. only one available actin for multiple myosin)
    if size(ds_mult, 2) == 1 && size(ds_mult, 1) ~= size(ds_mult, 2)
        ds_mult = ds_mult.'; %if there is only 1 free actin and multiple myosin, a_m_free_disp will be a column vector -> linear indexing of column vector gives a column vector intead of a row
        disp('transposed ds_mult \n');
    end
    ds_mult(ds_mult == 0) = 1; %replace 0's of logical array with 1
    min_disp_signed = ds_mult.'.*min_disp; %column vector of displacements with their true signs %PICKUP HERE STILL BREAKING WHEN MORE FREE MYOSIN THAN ACTIN
    %[min_disp, index] = cellfun(@min,a_m_free_cell_disp);
    
    %clear xb_conn_free
    xb_conn_free = zeros(3, size(m_free_indices, 2)); %matrix: row 2: all available (state 1) myosin nodes; row 1: index of closest actin; row 3: distance to closest actin from myosin node
    if size(m_free_indices, 2) ~= 0
        xb_conn_free(2,:) = m_free_indices; %row 2 has indices of state 1 myosin
        xb_conn_free(1,:) = a_free_indices(index.'); %row 1 has indices of closest actin
        xb_conn_free(3,:) = (min_disp_signed.'); %row 3 has distance to closest actin 
    end
    
    %clear index
%     if size(xb_crossover, 1) == 1
%         xb_conn_free = [];
%     end
       
    %Combine the xb_conn_free and xb_conn_bound matrices to form single matrix, xb_conn_comb, for use in rate constant calculations 
    %Concatenate xb_conn_free and xb_conn_bound horizontally
    xb_conn_comb = [xb_conn_free xb_conn_bound];
    [~, sort_cc_temp1] = sort(xb_conn_comb(2,:)); %sort myosin nodes in ascending order
    xb_conn_comb = xb_conn_comb(:, sort_cc_temp1); %sort entire matrix using the sorting indices of myosin
%     xb_conn_comb_plot
    %Store xb_conn_comb matrices
    xb_conn_comb_store(4*(t_index), 1) = t_index;
    xb_conn_comb_store(4*(t_index):4*(t_index)+2, 2:m_nodes+1) = xb_conn_comb;
    xb_conn_comb_store(4*(t_index)+1, (m_nodes+2):(2*m_nodes+1)) = N_states(t_index, a_nodes+2:tot_nodes-1);



    if size(xb_conn_comb, 2) ~= m_nodes
        disp('xb_conn_comb broke');
        disp(xb_conn_comb);
        pause
    end
    
    %Calculate rate constants
    %State 1 --> State 2 (Binding)  
    k12 = kbind.*exp(-0.25*B*kxb*(xb_conn_comb(3,:)).^2);
    K12 = exp(-B*(0.5*kxb*(xb_conn_comb(3,:)).^2 + dG_bind));
    k21 = k12./K12;
    
    %State 2 --> State 3 (Power Stroke)
    K23 = exp(-B*(dG_stroke - dG_c + (0.5*kxb*(2*xb_conn_comb(3,:)*d_ps+d_ps^2))+1/B*log(conc_ADP_vec(cf_ADP)*conc_P)));
    k23 = k23_cap*ones_m_nodes;
    k32 = k23./K23;
    
    %State 3 --> State 1 (Unbinding and Hydrolysis)
    K31 = exp(B*(dG_bind + dG_stroke + dG_hyd - dG_c + 0.5*kxb*((xb_conn_comb(3,:))+d_ps).^2+1/B*log(conc_ATP_vec(cf_ATP))));
    k13 = kATP0*ones_m_nodes;
    k31 = K31.*k13;
    % For tracking values of equilibrium constants K23 and rate constants k32 and k31. Observe dependence on changes in
    % [ATP] and [ADP]
    if N_states(t_index, a_nodes+2) == 3 %2
       K23_store(t_index, :) = K23; %Track K23 as concentration of ADP changes
       k32_store(t_index, :) = k32;
       k31_store(t_index, :) = k31;
    end
    
    %Concatenate rates
    rates = [k12; k21; k23; k32; k31; k13]; %vertical concatenation
    
% % % % % % % % % % %     if m_deactivation ==  true
% % % % % % % % % % %        rates_Mdeact = repmat([0;0;0;0;0;0], 1, length(m_deact));
% % % % % % % % % % %        rates = [rates, rates_Mdeact];
% % % % % % % % % % %     end
%     
    %Determine appropriate dt - sum of probabilities under prob_sum_maxed
    rates_123 = [rates(6,:); rates(1,:); rates(2:5,:)]; %reorganize rates so that it is [k13; k12; k21; k23; k32; k31] (backwards, forwards) pairs
    if m_nodes == 1 %store rates for Testcases where there is only one myosin
        rates_123_store(t_index, :) = [rates_123.', xb_state];
        eq_const_store(t_index, :) = [K12, K23, K31, xb_state];
    end
    for m = 1:m_nodes
       rates_relevant(:, m) = rates_123((xb_state(m)*2-1:xb_state(m)*2), m); %create a vector with the number of the myosin for the column (i.e. myosin 1, state 2 in column 1) and the the relevant rates (i.e. k21 & k23) as each row
       rates_summed(m,1) = sum(rates_123((xb_state(m)*2-1:xb_state(m)*2), m)); %create a vector with the number of the myosin for the row (i.e. myosin 1, state 2 in row 1) and the sum of the relevant rates (i.e. k21 + k23) as each value
    end
    
    %Determine appropriate dt - generate dt by dividing prob_sum_max_exact by the sum of forwards and backwards rates for all myosin
    %Creates a single probability bar with the same probability of "do nothing"
    %Eliminates possibility for double transition
    dt = prob_sum_max_exact/sum(rates_summed);
    
    %dt == 0 checker when doing TC 80.50, sometimes they all become 0 bc a rate constant = inf
    if sum(rates_summed == inf) >= 1 
        dt = min(dt_store).*(1e-2);
        fprintf('dt == 0 at t = %i on sim %i \n', t(t_index), totalSimCounter);
%         pause
    end
    
    
    %Determine appropriate dt - exact dt so probabilities equals prob_summed_max_exact
%{  
    max_rate_summed = max(rates_summed);
    dt = prob_sum_max_exact/max_rate_summed;
%}
%     if m_nodes == 2 && dt > dt_max
%         dt = dt_max;
%     end 
%      if N_states(t_index, a_nodes+2) == 3
%          disp done
%          pause
%      end

    %Determine appropriate dt - sum of probabilities under prob_summed_maxed
  %{  
    dt = dt_max;
    % reduce dt until the summed probability of the relevant transitions i.e. (k_ij + k_jk)*dt is < prob_summed_max
    while sum(rates_summed*dt > prob_summed_max) ~= 0
        dt = dt/10;
    end
%     dt_store(t_index) = dt; % <- now at end of contraction loop at t_index update
  %}
    
    %Calculate Probabilities
%     prob = (rates.*dt).'; %create matrix of probabilities (note: transposed)
    prob = rates_relevant(:).*dt; %Creates vector of (backward, forward) probability transition pairs for each myosin in order i.e. [m1 backwards, m1 forwards, m2 backwards, m2 forwards]
    prob_bin_edges = [cumsum(prob).', 1]; %Create vector of the edges of the probability bins for each transition, capping at 1.
     

end %end of double transition if statement

    %Assign each XB random value p* (0,1)
%     xb_prob = rand(1, m_nodes);
    
    %Assign a random value p* for the set of possible transitions
    xb_prob = rand;
    xb_trans_ind = find(xb_prob < prob_bin_edges, 1, 'first'); %Finds which transition "bin" the random xb_prob falls into. Gives index of upper end of bin.
    if sum(rates_summed == inf) >= 1 
        xb_trans_ind = find(rates_relevant == inf, 1, 'first');
        if sum(rates_relevant == inf, 'all') > 1
            fprintf('At t = %i and t_ind = %i of sim = %i, there is more than one rate that is inf. \n', t(t_index), t_index, totalSimCounter);
        end
    end
    
%     xb_prob_store(t_index, :) = xb_prob;
% if a_nodes > 1
%     prob_store(t_index, :) = [prob(1, :), N_states(t_index, a_nodes+2), xb_prob(1), xb_prob(2), N_states(t_index, a_nodes+3), prob(2, :)];
% end
% Store probabilities of transitions when there is more than one myosin head
%{
    prob_store_mult((m_nodes+1)*t_index, 1) = t_index; %place time in first column
    prob_store_mult((m_nodes+1)*t_index, 11) = dt; %place dt in first row, 11th column
    prob_store_mult((m_nodes+1)*t_index+1, 11) = t(t_index); %place current time under dt in 11th column
    prob_store_mult((m_nodes+1)*t_index:(m_nodes+1)*t_index+(m_nodes-1), 2) = round((N_states(t_index, a_nodes+2:tot_nodes-1).' + 0.001*[a_nodes+2:1:a_nodes+1+m_nodes].'), 3); %place states of all myosin
    prob_store_mult((m_nodes+1)*t_index:(m_nodes+1)*t_index+(m_nodes-1), 3:8) = prob; %place probabilities for each myosin 
    prob_store_mult((m_nodes+1)*t_index:(m_nodes+1)*t_index+(m_nodes-1), 10) = xb_prob.'; %place the Monte Carlo value assigned to the myosin head for this iteration of the cycle 
%}


    %To quickly search prob_store_mult:
%     time of double transition = x
%     Data for time of double transition = x*m_nodes + m_nodes
%     Lower limit = x*m_nodes - (m_nodes + ~5)*iterations before x you want to see
%     Upper limit = x*m_nodes + (m_nodes + ~5)*(iterations after x you want to see + 1)
    %In command window: openvar('prob_store_mult(150900:150960,:)')
    
    %Determine whether state transition will occur, transitions will be a... 
    %...1 by m_nodes array: +1 = forward, -1 =  backwards, +2 = 1->3 transition, -2 = 3->1 transition, 0 = no transition
    %{
    xb_transitions = (xb_state == 1).*((xb_prob < prob(:, 1).') + (2*((xb_prob >= prob(:,1).').*(xb_prob < (prob(:,1).'+ prob(:, 6).')))))...
                    +(xb_state == 2).*((xb_prob < prob(:, 3).') - ((xb_prob >= prob(:,3).').*(xb_prob < (prob(:,3).'+ prob(:, 2).'))))...
                    +(xb_state == 3).*((-2*(xb_prob < prob(:,5).')) - ((xb_prob >= prob(:,5).').*(xb_prob < (prob(:,5).' + prob(:,4).'))));
    %}
    
    xb_trans_dir = mod(xb_trans_ind, 2); %What direction is myosin transitioning? 0 = forward, 1 = backwards or do nothing/no transition
    xb_trans_myo = ceil(xb_trans_ind/2); %Which myosin is transitioning?
    xb_transitions = zeros(1, m_nodes); %Set xb_transitions in the case that "do nothing" was chosen
    if xb_trans_myo <= m_nodes %Change xb_transitions if a transition occurred for a myosin
        xb_trans_data = zeros(1, m_nodes);
        xb_trans_data(xb_trans_myo) = 1;
        if xb_trans_dir == 0 %forward transition
            xb_transitions = (xb_state == 1).*(xb_trans_data) + (xb_state == 2).*(xb_trans_data) - 2*(xb_state == 3).*(xb_trans_data);
        else %backwards transition
            xb_transitions = 2*(xb_state == 1).*(xb_trans_data) - (xb_state == 2).*(xb_trans_data) - (xb_state == 3).*(xb_trans_data);
        end
    end
    
    xb_transitions(isnan(xb_conn_comb(3,:))) = 0; %prevent 1->3 transition from occuring when no actin available i.e. xb_conn_comb(3,n) = NaN
    
    % Store probabilities of transitions when there is more than one myosin head - new probability bar
    if exist('prob_store_mult2', 'var')
        psm2_nextStart = find(prob_store_mult2(:, 1) == 0, 1, 'last')+1;
    else
        psm2_nextStart = (m_nodes+1)*t_index; 
    end
    prob_store_mult2(psm2_nextStart, 1:6) = [t_index, t(t_index), dt, xb_prob, xb_trans_myo, xb_trans_dir]; %LEGEND row 1
%     prob_store_mult2((m_nodes+1)*t_index+1, 1);
%     prob_store_mult2((m_nodes+1), 1);
    prob_store_mult2(psm2_nextStart+1, 2:2+m_nodes-1) = round((N_states(t_index, a_nodes+2:tot_nodes-1) + 0.001*[a_nodes+2:1:a_nodes+1+m_nodes]), 3); %place (states of all myosin).(number label of myosin)
%     prob_store_mult2((m_nodes+1)*t_index:(m_nodes+1)*t_index+(m_nodes-1), 2) = round((N_states(t_index, a_nodes+2:tot_nodes-1).' + 0.001*[a_nodes+2:1:a_nodes+1+m_nodes].'), 3); %place states of all myosin.number label of myosin
    prob_store_mult2(psm2_nextStart+2, 2:2+m_nodes-1) = prob_bin_edges(1:2:end-1); %2nd row has the probability bin cut off for the backwards transition for each myosin
    prob_store_mult2(psm2_nextStart+3, 2:2+m_nodes-1) = prob_bin_edges(2:2:end-1); %3rd row has the probability bin cut off for the forwards transition for each myosin
    
    
    
    % Simulate step function of ATPase
    if ATPase_stepfunc == true
        dt = dt_max;
        if mod(ATPase_step, 2) == 0
           xb_transitions = -2; % myosin st 3 -> st 1
        else
           xb_transitions = 2; % myosin st 1 -> st 3
        end
    end
    %For TC 3.11
    %dt st. 3 = 1.157693233291981e-04
    %dt st. 1 = 0.001124985937676
    %dt st. 2 = 0.002860298164544
    if ATPase_CycleThru == true
        if mod(ATPase_step, 3) == 0
           xb_transitions = -2; % myosin st 3 -> st 1
           dt = 1.157693233291981e-04;
        else
           xb_transitions = 1; % myosin st 1 -> st 2 or st 2 -> st 3
           if mod(ATPase_step, 3) == 1 %state 1
               dt = 0.001124985937676;
           else %state 2
               dt = 0.002860298164544;
           end
        end
    end
    ATPase_step = ATPase_step + 1;
    %commented out below is the line that tells ATPase_tracker that if xb_trnsitions = 2, then track that as reverse ATP hydrolysis
        
    xb_trans_store(t_index, :) = xb_transitions;
%     xb_transitions = [0, 1];
    
    %Check for > 1 transition happening during one time step
    if sum(xb_transitions~=0) > 1
% %         disp(t_index);
% %         fprintf('double transition, t_index = %f \n', t_index);
        dt_counter = dt_counter+1;
%         if dt_counter > 50000
%             %t_index = tot_timesteps; %End this simulation early
% %             fprintf('Probably a probability error, forwards + backwards probability sum to >1 \n');
%             fprintf('Experienced >50000 double transitions at t = %i \n', t_index);
%             beep
%             pause
%         end
% %         pause
        continue
    else
        dt_counter = 0;
    end
    
    
    
%Begin updates for next timestep
    
    %Update xb_state matrix [final update before end of timestep]
    xb_state = xb_state + xb_transitions;
%     xb_state_store(t_index+1, :) = xb_state;
    
    %Update xb_conn_bound matrix with the binding transition 
    xb_conn_bound = xb_conn_comb(:, xb_state ~=1);
    xb_conn_bound_store{t_index+1} = xb_conn_bound;
    
    %Update xb_conn_free matrix with any unbinding transitions
    xb_conn_free = xb_conn_comb(:, xb_state == 1);
    xb_conn_free_store{t_index+1} = xb_conn_free;
    
    %Update a_state for time t_index+1 [final update before end of timestep]
    N_states(t_index+1, xb_conn_bound(1,:)) = 1;
    a_state = N_states(t_index+1, 2:a_nodes+1);
%     a_state_store(t_index+1, :) = a_state;
        
    %Update myosin/xb states for t_index+1 in N_states [final update before end of timestep]
    N_states(t_index+1, a_nodes+2:tot_nodes-1) = N_states(t_index, a_nodes+2:tot_nodes-1) + xb_transitions;
    
    %Track transitions between states
%     if sum(xb_transitions~=0) ~= 0
%         trans_pathways(t_index, 1) = N_states(t_index, a_nodes+1+find(xb_transitions~=0));
%         trans_pathways(t_index, 2) = xb_transitions(xb_transitions~=0);
%     end
    
    %Track myosin residence times in each state
    for m = 1:m_nodes
        if xb_transitions(m)~=0
            %Tell m_res_tracker which state you are now moving into
            m_res_tracker(m, N_states(t_index+1, a_nodes+1+m)) = m_res_tracker(m, N_states(t_index+1, a_nodes+1+m)) + 1; %increment m_dwell_tracker when entering a new state
            %First 6 rows describe t_index when m1 enters or leaves each state: s1_in, s1_out, s2_in, s2_out, s3_in, s3_out
            %Fill the "out" row for the CURRENT state with current t_index
            m_res_times((m-1)*6 + N_states(t_index, a_nodes+1+m)*2, m_res_tracker(m, N_states(t_index, a_nodes+1+m))) = t_index;
            %Fill the "in" row for the NEXT state with the t_index+1
            m_res_times((m-1)*6 + N_states(t_index+1, a_nodes+1+m)*2-1, m_res_tracker(m, N_states(t_index+1, a_nodes+1+m))) = t_index;
            break %there can only be one myosin undergoing transition per time step 
        end
    end
    
    %Calculate and update average residence times every 10 time steps - residence time calculation only works if all myosin made at least one full cycle
    %{
    if mod(t_index, 10) == 0 && size(m_res_times, 1) == m_nodes*6
        if m_res_times(m_res_initial+5, 1) ~= 0
            for m = 1:m_nodes
                %Find average of the difference between t_out and t_in for each state
%                 avg_s1 = mean(m_res_times((m-1)*6+2,1:find(m_res_times((m-1)*6+2,:), 1, 'last')) - m_res_times((m-1)*6+1, 1:find(m_res_times((m-1)*6+2,:), 1, 'last')));
%                 avg_s2 = mean(m_res_times((m-1)*6+4,1:find(m_res_times((m-1)*6+4,:), 1, 'last')) - m_res_times((m-1)*6+3, 1:find(m_res_times((m-1)*6+4,:), 1, 'last')));
%                 avg_s3 = mean(m_res_times((m-1)*6+6,1:find(m_res_times((m-1)*6+6,:), 1, 'last')) - m_res_times((m-1)*6+5, 1:find(m_res_times((m-1)*6+6,:), 1, 'last')));
                avg_s1 = mean(t(m_res_times((m-1)*6+2,1:find(m_res_times((m-1)*6+2,:), 1, 'last'))) - t(m_res_times((m-1)*6+1, 1:find(m_res_times((m-1)*6+2,:), 1, 'last'))));
                avg_s2 = mean(t(m_res_times((m-1)*6+4,1:find(m_res_times((m-1)*6+4,:), 1, 'last'))) - t(m_res_times((m-1)*6+3, 1:find(m_res_times((m-1)*6+4,:), 1, 'last'))));
                avg_s3 = mean(t(m_res_times((m-1)*6+6,1:find(m_res_times((m-1)*6+6,:), 1, 'last'))) - t(m_res_times((m-1)*6+5, 1:find(m_res_times((m-1)*6+6,:), 1, 'last'))));
                avg_res_times(m,:) = [avg_s1, avg_s2, avg_s3]; 
            end
        end        
    end
    %}

    %Update ATPase tracker by tracking 3 -> 1 ATP hydrolysis step 
    if sum(xb_transitions == -2) == 1
        ATPase_tracker(1, t_index) = 1; % Increase ATP tracker's count by 1 for 3 -> 1 transition
        ATPase_ea_m(1, xb_transitions == -2) = ATPase_ea_m(xb_transitions == -2) + 1;
    %Can eventually remove the ATPase_stepfunc logical, only present to simulate step function for ATPase
    elseif ATPase_stepfunc == false && sum(xb_transitions == 2) == 1
        ATPase_tracker(1, t_index) = -1; % Decrease ATP tracker's count by 1 for 1 -> 3 transition
        ATPase_ea_m(1, xb_transitions == 2) = ATPase_ea_m(xb_transitions == 2) - 1;
    end

    ATPase_tracker_plot(1, t_index+1) = sum(ATPase_tracker);
    
    
    %Update V matrix for t_index+1 with kxb*xb0 terms and adjusted xb_0 values for state 3 myosin (post-power stroke myosin rest length = xb_0 - d_ps)
    V_xb = zeros(tot_nodes-1, 1);
    xb_st2_ind = [find(xb_state == 2)+a_nodes+1]; %array of indicies of myosin in state 2
    V_state2_temp = ismember(xb_conn_bound(2,:), xb_st2_ind); %indices of xb_conn_bound(2,:) that are in state 2
    V_state2 = [(xb_conn_bound(1, V_state2_temp)-1) (xb_conn_bound(2, V_state2_temp)-1)]; %array of actin indices bound to state 2 myosin and the state 2 xb
                                              %(-1) is because V matrix does not have az node, so indices of V matrix are shifted back by 1
    
    xb_st3_ind = [find(xb_state == 3)+a_nodes+1]; %array of indicies of myosin in state 3
    V_state3_temp = ismember(xb_conn_bound(2,:), xb_st3_ind); %indices of xb_conn_bound(2,:) that are in state 3
    V_state3 = [(xb_conn_bound(1, V_state3_temp)-1) (xb_conn_bound(2, V_state3_temp)-1)]; %array of actin indices bound to state 3 myosin and the state 3 xb
                                              %(-1) is because V matrix does not have az node, so indices of V matrix are shifted back by 1

    %Original V_xb
    V_xb(V_state2) = kxb*(xb0); 
    V_xb(V_state3) = kxb*(xb0 - d_ps);
    %V = V_reset; %Set V from the previous time step back to its base (no cross-bridges)
%     V = V_reset + V_xb_mult.*V_xb;
    
    %Different V when (mM - az) < xhs
%     if round((N_locations(t_index, tot_nodes) - a_z), 14) < round(xhs, 14)
%          V = V_reset_short + V_xb_mult.*V_xb;
%     end

    V = V_reset_short + V_xb_mult.*V_xb;

% % % % %     %TEST CASE: Apply external force in middle of simulation - moved to outside t_Ca statement
% % % % %     if (t(t_index) >= t_appforce) && (t(t_index) < t_removeforce)
% % % % %         V_ext_force = V_reset_short;
% % % % %         V_ext_force(tot_nodes-1) = - km*m0 -kF*(xf_new - xf0); %redefine with new xf value
% % % % %         V = V_ext_force + V_xb_mult.*V_xb;
% % % % %     end

    %Create array giving indices of xb_conn_K where a XB occurs
    %xb_conn_comb_K = [xb_conn_free(:, a_state == 0) xb_conn_bound]; %create updated xb_conn_comb matrix that includes transitions
    %xb_cck_temp = ~ismember(xb_conn_free(1,:), find(a_state == 1)); %indices of xb_conn_free(1,:) actin that are nearest to a free myosin and are unbound (0)
    %xb_cck_temp = ismember(xb_conn_free(2,:), find(xb_state == 1)+a_nodes+1);  %indices of xb_conn_free(2,:) myosin that are still unbound
    %xb_conn_comb_K = [xb_conn_free(:, xb_cck_temp) xb_conn_bound]; %Matrix of: [state 1 myosin (row 2) and the nearest state 0 actin (row 1) , state 2 or 3 myosin (row 2 cont.) and the state 1 actin they are bound to (row 1 cont.)] Diplacements in row 3

    xb_conn_comb_K = [xb_conn_free xb_conn_bound];
    [~, sort_ck_temp] = sort(xb_conn_comb_K(2,:)); %sort myosin nodes in ascending order
    xb_conn_comb_K = xb_conn_comb_K(:, sort_ck_temp); %sort entire matrix using the sorting indices of myosin
    xb_conn_comb_K(1, xb_state == 1) = 0; %second row contains all possible XB indices (m1 - mn), first row is (0) when unbound or (an = actin index) when bound
    xb_conn_K = xb_conn_comb_K; %rename as xb_conn_K
%     xb_conn_K_store(:, :, t_index) = xb_conn_K;
    %example connections
    %xb_conn_K(1,1) = 2; %example, myosin node 4 bound to actin node 2
    %xb_conn_K(1, 2) = 3; %example, myosin node 5 bound to actin node 3
    xb_index = find(xb_conn_K(1,:)); %indices of bound actin in xb_conn_K(1,:) i.e. XB present
    xb_mat = zeros(size(K)); %initialize xb_mat again before introducing XBs
    clear xb_loc;
    %Create arrays of the LINEAR indices (1 to tot_nodes^2) of xb_mat (and thus K matrix) where kxb should exist
    xb_loc(1, :) = (tot_nodes-1)*(xb_conn_K(1, xb_index)-2)+(xb_conn_K(1, xb_index)-1); %track indices of xb_mat (1 to (tot_nodes-1)^2) that are (an, an)
    xb_loc(4, :) = (tot_nodes-1)*(xb_conn_K(2, xb_index)-2)+(xb_conn_K(2, xb_index)-1); %track indices of xb_mat (1 to (tot_nodes-1)^2) that are (mn, mn)
    xb_loc(2, :) = (tot_nodes-1)*(xb_conn_K(2, xb_index)-2)+(xb_conn_K(1, xb_index)-1); %track indices of xb_mat (1 to (tot_nodes-1)^2) that are (an, mn)
    xb_loc(3, :) = (tot_nodes-1)*(xb_conn_K(1, xb_index)-2)+(xb_conn_K(2, xb_index)-1); %track indices of xb_mat (1 to (tot_nodes-1)^2) that are (mn, an)
    xb_mat([xb_loc(1,:), xb_loc(4, :)]) = -1; %set (an, an) and (mn, mn) values of xb_mat to -1
    xb_mat([xb_loc(2, :), xb_loc(3,:)]) = 1; %set (an, mn) and (mn, an) values of xb_mat to 1
%     xb_mat_store(:, :, t_index) = xb_mat;

end %end t_Ca if statement
    
if t_Ca_counter <= t_Ca %Before contraction begins
    %Update all locations of t_index + 1 to be what they were in t_index 
    %N_locations(t_index+1,:) = N_locations(t_index, :);
    %Update all states of t_index + 1 to be what they were in t_index
    N_states(t_index+1, :) = N_states(t_index, :);
    V = V_reset_short;
end

%TEST CASE: Apply external force in middle of simulation
% % % % % % % % % if (t(t_index) >= t_appforce) && (t(t_index) < t_removeforce)
% % % % % % % % %     V_ext_force = V_reset_short;
% % % % % % % % %     V_ext_force(tot_nodes-1) = - km*m0 -kF*(xf_new - xf0); %redefine with new xf value
% % % % % % % % %     V = V_ext_force + V_xb_mult.*V_xb;
% % % % % % % % % end
    
    %Different K when (mM - az) < titin_0
%     if round((N_locations(t_index, tot_nodes) - a_z), 14) < round(xhs, 14)
%         K = K_reset_short + kxb.*xb_mat;
%     end
    
%Update the K matrix and solve for P
    K = K_reset_short + kxb.*xb_mat;
    
    P = K\V;
%     K_inv_store(:, :, t_index) = inv(K);
    K_store(:, :, t_index) = K;
    V_store(:, :, t_index) = V;
    N_locations(t_index+1, 2:tot_nodes) = P.';
    % If the sarcomere is stretched beyond its original rest length, enter this statement below
    if round((N_locations(t_index+1, tot_nodes) - a_z), 14) > round(xhs, 14)
        K = K_reset + kxb.*xb_mat;
        V = V_reset + V_xb_mult.*V_xb;
% % % % % % % % %         %When external Force is applied
% % % % % % % % %         if (t(t_index) >= t_appforce) && (t(t_index) < t_removeforce)
% % % % % % % % %             V_ext_force = V_reset;
% % % % % % % % %             V_ext_force(tot_nodes-1) = - km*m0 - kF*(xf_new - xf0); %redefine with new xf value
% % % % % % % % %             V = V_ext_force + V_xb_mult.*V_xb;
% % % % % % % % %         end
        P = K\V;
%         K_inv_store(:, :, t_index) = inv(K);
        K_store(:, :, t_index) = K;
        V_store(:, :, t_index) = V;
        N_locations(t_index+1, 2:tot_nodes) = P.';
    end
    
    %Update xb_conn_bound displacements with values from solved mechanical equilibrium position array (P)
    if size(xb_conn_bound, 2) > 0
        xb_conn_bound(3, :) = (P(xb_conn_bound(2,:)-1) - P(xb_conn_bound(1,:)-1) - xb0).';
    end
    
%% Output Storage for Timestep

%Output: Store Force
    %Use m_M to calculate and output force of external spring (which is equal force generated by hs)
    %Force is generated by the states of actin and myosin nodes during t_index
    F_output(1, t_index+1) = kF*(xf-P(tot_nodes-1)-xf0)*(1e12); %F_output converted from N to pN and saved as pN
    F_output_mline(1, t_index+1) = km*(P(tot_nodes-1) - P(tot_nodes-2) - m0)*(1e12);

    
% % % % % % % % %     %When external Force is applied
% % % % % % % % %     if (t(t_index) >= t_appforce) && (t(t_index) < t_removeforce)
% % % % % % % % %         F_sarc_store(t_index+1, 1) = kF*((round(xf_new, 14) - round(P(tot_nodes-1), 14) - xf0) - (kF*(F_appforce/kF)))*(1e12);
% % % % % % % % %         F_output(1, t_index+1) = kF*(xf_new-P(tot_nodes-1)-xf0)*(1e12);
% % % % % % % % %     end
%================================================================================================================    
%Output: Store Force generated by titin (only when titin is stretched, otherwise F_titin = 0;
if round(N_locations(t_index+1, a_nodes+2), 14) <= titin0
    F_titin = 0; %Titin does not produce a compressive force when compressed, it only produces resisting tensile force when stretched
else
    F_titin = k_titin*(round(N_locations(t_index+1, a_nodes+2), 14) - titin0)*(1e12); %N_locations(t_index_1, a_nodes+2) is position of first myosin. Z-line fixed at 0 so N_locations(t_index_1, a_nodes+2) at t = 0 is equivalent to titin0, any stretch from this is a deformation.
end
F_titin_store(t_index+1, 1) = F_titin;
F_titin_store(t_index+1, 2) = NaN;
F_titin_store(t_index+1, 3) = F_output(1, t_index+1);
% % % % % % % % % % % % titin_kext_deformation(t_index+1, 1:2) = (1e9)*[round(N_locations(t_index+1, a_nodes+2), 14) - titin0, (round(xf_new, 14) - round(N_locations(t_index+1, tot_nodes), 14)) - (round(xf_new, 14) - round(N_locations(1, tot_nodes), 14))];
% First value is length that titin elongates by after external force is applied (no xb attached)
% Second value is length that the spring_ext shortens by in between [xf_new (when force is applied) - m_M (before force applied)] and [xf_new - m_M (after force is applied)]
%================================================================================================================
% % % % % % % % % %Output: Store Passive Force, Active Force, and Total F_output in one matrix
% % % % % % % % % F_pass(t_index+1, 1:3) = [F_titin, F_output(1, t_index+1) - F_titin, F_output(1, t_index+1)];
% % % % % % % % % %Output: "Active Force" F_ouput - applied force
% % % % % % % % % if (t(t_index) >= t_appforce) && (t(t_index) < t_removeforce)
% % % % % % % % %     F_active(t_index+1, 1) = F_output(1, t_index+1) - F_appforce*(1e12);
% % % % % % % % %     F_ext(t_index+1, 1) = F_appforce*(1e12);
% % % % % % % % % else
% % % % % % % % %     F_active(t_index+1, 1) = F_output(1, t_index+1);
% % % % % % % % %     F_ext(t_index+1, 1) = 0;
% % % % % % % % % end
%================================================================================================================
%Output: Store Force generated by each myosin spring in matrix, columns: myosin, rows: t_index
    for j = 1:m_nodes
        F_m_store(t_index+1, j) = km*(N_locations(t_index+1, a_nodes+2+j) - N_locations(t_index+1, a_nodes+1+j) - m0)*(1e12); %Force generated by each myosin spring (pN)
    end
    F_m_store(t_index+1, m_nodes+1) = NaN; %spacer
    F_m_store(t_index+1, m_nodes+2) = sum(F_m_store(t_index+1, 1:m_nodes)); %total forces of myosin
    F_m_store(t_index+1, m_nodes+3) = F_output(1, t_index+1); %F_output
%================================================================================================================
%Output: Store Force generated by each myosin cross bridge (xb) in matrix, columns: myosin xb coming from node N, rows: t_index
    for i = 1:size(xb_conn_bound, 2)
    %     F_xb_store(t_index+1, xb_conn_bound(2, i) - a_nodes - 1) = kxb*(N_locations(t_index+1, xb_conn_bound(2, i)) - N_locations(t_index+1, xb_conn_bound(1, i)) - xb0);
        F_xb_store(t_index+1, xb_conn_bound(2, i) - a_nodes - 1) = kxb*(xb_conn_bound(3, i))*(1e12); 
        if N_states(t_index+1, xb_conn_bound(2, i)) == 3
            F_xb_store(t_index+1, xb_conn_bound(2, i) - a_nodes - 1) = kxb*(N_locations(t_index+1, xb_conn_bound(2, i)) - N_locations(t_index+1, xb_conn_bound(1, i)) - (xb0 - d_ps))*(1e12);
        end
    end
    % F_xb_store(t_index+1, m_nodes+1:m_nodes+2) = [NaN, sum(F_xb_store(t_index+1, 1:m_nodes))];
    F_xb_store(t_index+1, m_nodes+1) = NaN;
    F_xb_store(t_index+1, m_nodes+2) = sum(F_xb_store(t_index+1, 1:m_nodes));
    F_xb_store(t_index+1, m_nodes+3) = F_output(1, t_index+1);
    F_xb_store(t_index+1, m_nodes+4) = F_xb_store(t_index+1, m_nodes+3) - F_xb_store(t_index+1, m_nodes+2); %Force generated by elements of hs other than xb's, F_output - sum(F_xb_store) <- value makes less sense bc things are in series/parallel so it is more complex than this because springs in series all have same force through them
    
%================================================================================================================
%Output: Average Force for last 20 timesteps %Can probably use arrayfun to do this at the end --> ended up doing this see plotting section below
%     if mod(t./dt, 20) == 0
%         Avg_F_output_periodic(1, t_index) = mean(F_output(1, t_index+1-20:t_index));
%     end
        
%================================================================================================================
%Output: Store Work
    %Calculate and store Work (W = F*displacement)
    %Work is when half-sarcomere length is departing from rest length relative to previous location
    if (((round(N_locations(t_index, tot_nodes), 14) - round(N_locations(t_index+1, tot_nodes), 14)) > 0) && (round(N_locations(t_index+1, tot_nodes), 14) < round(xhs, 14)))... %if the sarcomere is shortening away from rest length
            || (((round(N_locations(t_index, tot_nodes), 14) - round(N_locations(t_index+1, tot_nodes), 14)) < 0) && (round(N_locations(t_index+1, tot_nodes), 14) > round(xhs, 14))) %if the sarcomere is lengthening away from rest length
        work = F_output(1, t_index)*(N_locations(t_index, tot_nodes) - N_locations(t_index+1, tot_nodes)); %Work is positive moving away from the xhs rest length
        work_store(t_index+1, 1) = work*1e-12; %F_output stored in pN, so 1e-12 converts units pN*m to N*m = J %was originally 1e7, why?
    end
%================================================================================================================    
    
%{    
if m_nodes == 2  %a_nodes == 2
    %Calculate Force on each node, positive force is in +x direction, stored in pN
    %Z-line
    F_store(t_index+1, 1) = 1e12*(ka*(N_locations(t_index, 2) - a_z - a0)+ k_titin*(N_locations(t_index, 4) - a_z - titin0));
    %Assume things are unbound and calculate those forces
    F_store(t_index+1, 2) = 1e12*(ka*(N_locations(t_index, 3) - N_locations(t_index, 2) - a0) - ka*(N_locations(t_index, 2) - a_z - a0));
    F_store(t_index+1, 3) = 1e12*(-ka*(N_locations(t_index+1, 3) - N_locations(t_index+1, 2) - a0));% + kxb*(N_locations(t_index+1, 5) - N_locations(t_index+1, 3) - xb0 + d_ps));
    F_store(t_index+1, 4) = 1e12*(km*(N_locations(t_index+1, 5) - N_locations(t_index+1, 4) - m0) - k_titin*(N_locations(t_index+1, 4) - a_z - titin0));
    F_store(t_index+1, 5) = 1e12*(-km*(N_locations(t_index+1, 5) - N_locations(t_index+1, 4) - m0) + km*(N_locations(t_index+1, 6) - N_locations(t_index+1, 5) - m0));% - kxb*(N_locations(t_index+1, 5)-N_locations(t_index+1, 3)- xb0 + d_ps));
    F_store(t_index+1, 6) = 1e12*(-km*(N_locations(t_index+1, 6) - N_locations(t_index+1, 5) - m0) + kF*(xf - N_locations(t_index+1, 6) - xf0)); 
    %Check for binding
    %Forces if myosin 4 is bound
    if N_states(t_index+1, 4) == 2 || N_states(t_index+1, 4) == 3
        F_store(t_index+1, xb_conn_comb(1, 1)) = 1e12*(ka*(N_locations(t_index+1, 3) - N_locations(t_index+1, 2) - a0) - ka*(N_locations(t_index+1, 2) - a_z - a0)+ kxb*(xb_conn_comb(2, 1) - xb_conn_comb(1, 1) - xb0 + d_ps));
        F_store(t_index+1, 4) = 1e12*(km*(N_locations(t_index+1, 5) - N_locations(t_index+1, 4) - m0) - k_titin*(N_locations(t_index+1, 4) - a_z - titin0) - kxb*(xb_conn_comb(2, 1) - xb_conn_comb(1, 1) - xb0 + d_ps));
    end
    %Forces if myosin 5 is bound
    if N_states(t_index+1, 5) == 2 || N_states(t_index+1, 5) == 3
        F_store(t_index, xb_conn_comb(1, 2)) = 1e12*(-ka*(N_locations(t_index+1, 3) - N_locations(t_index+1, 2) - a0) + kxb*(xb_conn_comb(2, 2) - xb_conn_comb(1, 2) - xb0 + d_ps));
        F_store(t_index, 5) = 1e12*(-km*(N_locations(t_index+1, 5) - N_locations(t_index+1, 4) - m0) + km*(N_locations(t_index+1, 6) - N_locations(t_index+1, 5) - m0) - kxb*(xb_conn_comb(2, 2) - xb_conn_comb(1, 2) - xb0 + d_ps));
    end
    %Node 6 specifics
%     F_store(t_index, 7) = 6;
%     F_store(t_index, 8) = -km*(N_locations(t_index, 6) - N_locations(t_index, 5) - m0)*1e12; %Force on node 6
%     F_store(t_index, 9) = N_locations(t_index, 6) - N_locations(t_index, 5);
%     F_store(t_index, 10) = m0;

end
%}
%================================================================================================================    
%Output: Store Strain
    %m_M to calculate and output strain on hs
    strain_hs(1, t_index+1) = (xhs - P(tot_nodes-1))/xhs;
    %disp(strain_hs(t_index)); %[NOT GETTING ZERO; some discrepancy between precision of xhs and P array values]
    
    %Preliminary updating of time, will also be done again at beginning of
    %next timestep, only for plotting time = 0 case
    %t(t_index+1) = dt*(t_index); %note: t_index started at 1, not 0, so it is inherently (time + 1)
    
% % % % % % % % % % % % % % % % % % %     if (t_index*dt >= t_appforce) && (t_index*dt < t_removeforce)
% % % % % % % % % % % % % % % % % % %         sum(m4_1(t_appforce/dt:t_removeforce/dt) == m5_1(t_appforce/dt:t_removeforce/dt) & m4_1(t_appforce/dt:t_removeforce/dt) == 1 & m5_1(t_appforce/dt:t_removeforce/dt) == 1)-t_Ca);
% % % % % % % % % % % % % % % % % % %         
% % % % % % % % % % % % % % % % % % %     end
%================================================================================================================
%Output: Store Elastic Potential Energy of External Spring (in N*m or J)
% E_potential_ext(t_index+1, 1) = 0.5*kF*(round(P(tot_nodes-1), 14) - round(xhs, 14))^2;
E_potential_ext(t_index+1, 1) = 0.5*kF*(round(xf, 14) - round(P(tot_nodes-1), 14) - xf0)^2;
if (round(xf, 14) - round(P(tot_nodes-1), 14)) < 0 %Check if M-line is pushed out beyond anchor of external spring (highly unlikely)
    disp("M-line pushed beyond anchor of external spring");
end
% % % % % % % % % % % % % % % % % % % % % % % % % % if (t(t_index) >= t_appforce) && (t(t_index) < t_removeforce)
% % % % % % % % % % % % % % % % % % % % % % % % % %         E_potential_ext(t_index+1, 1) = 0.5*kF*(round(xf_new, 14) - round(N_locations(t_index+1, tot_nodes), 14) - xf0)^2;
% % % % % % % % % % % % % % % % % % % % % % % % % % %         E_potential_ext_sarc(t_index+1, 1) = 0.5*kF*(round(xf_new, 14) - round(P(tot_nodes-1), 14) - xf0)^2 - (0.5*kF*(appforce/kF)^2);
% % % % % % % % % % % % % % % % % % % % % % % % % %         E_potential_ext_sarc(t_index+1, 1) = 0.5*kF*(round(xf_new, 14) - round(N_locations(t_index+1, tot_nodes), 14) - xf0)^2 - (0.5*kF*(F_appforce/kF)^2);
% % % % % % % % % % % % % % % % % % % % % % % % % % %         E_potential_titin(t_index+1, 1) = 0.5*k_titin*(round(N_locations(t_index+1, a_nodes+2), 14) - titin0)^2; %N_locations(t_index+1, a_nodes+2) is position of first myosin. Z-line fixed at 0 so N_locations(t_index+1, a_nodes+2) at t = 0 is equivalent to titin0, any stretch from this is a deformation
% % % % % % % % % % % % % % % % % % % % % % % % % % end
if round(N_locations(t_index+1, a_nodes+2), 14) <= titin0
    E_potential_titin(t_index+1, 1) = 0; %Titin does not produce a compressive force when compressed, it only produces resisting tensile force when stretched
else
    E_potential_titin(t_index+1, 1) = 0.5*k_titin*(round(N_locations(t_index+1, a_nodes+2), 14) - titin0)^2; %N_locations(t_index+1, a_nodes+2) is position of first myosin. Z-line fixed at 0 so N_locations(t_index+1, a_nodes+2) at t = 0 is equivalent to titin0, any stretch from this is a deformation
end
Epot_data(t_index+1, 1:2) = (1e21)*[E_potential_ext(t_index+1, 1), E_potential_titin(t_index+1, 1)]; %converts to units pn*nm %(1) potential energy of external spring (2) potential energy of titin

%================================================================================================================
%Output: Store Elastic Potential Energy of Every Spring in System (in N*m or J)
%Epot for Cross Bridges
clear Epot_xb_temp
for i = 1:size(xb_conn_bound, 2)
    Epot_xb_temp(xb_conn_bound(2, i) - a_nodes - 1) = 0.5*kxb*(xb_conn_bound(3, i)^2); %Epot of the bound cross bridges
    if N_states(t_index+1, xb_conn_bound(2, i)) == 3
        Epot_xb_temp(xb_conn_bound(2, i) - a_nodes - 1) = 0.5*kxb*(N_locations(t_index+1, xb_conn_bound(2, i)) - N_locations(t_index+1, xb_conn_bound(1, i)) - (xb0 - d_ps))^2;
    end
Epot_xb_store(t_index+1) = sum(Epot_xb_temp); %total Epot of cross bridges for this timestep    
end
if size(xb_conn_bound, 2) == 0
    Epot_xb_store(t_index+1) = 0; %total Epot of cross bridges for this timestep
end

%Epot for each myosin spring in matrix, columns: myosin, rows: t_index
clear Epot_m_temp
for j = 1:m_nodes
    Epot_m_temp(j) = 0.5*km*(N_locations(t_index+1, a_nodes+2+j) - N_locations(t_index+1, a_nodes+1+j) - m0)^2; %Epot each myosin spring
end
Epot_m_store(t_index+1) = sum(Epot_m_temp); %total Epot of myosin for this timestep

%Epot for each actin spring in the matrix
clear Epot_a_temp
for j = 1:a_nodes
    Epot_a_temp(j) = 0.5*km*(N_locations(t_index+1, j+1) - N_locations(t_index+1, j) - a0)^2; %Epot each myosin spring
end
Epot_a_store(t_index+1) = sum(Epot_a_temp); %total Epot of myosin for this timestep

%Epot for titin - solved above, stored again here for simplicity
Epot_titin_store(t_index+1) = E_potential_titin(t_index+1, 1);

%Epot for external spring - solved above, stored again here for simplicity
Epot_ext_store(t_index+1) = (1e21)*E_potential_ext(t_index+1, 1); %row vector

%Store Epot data for all springs in system
Epot_IntSprings_data(t_index+1, 1:4) = (1e21)*[Epot_a_store(t_index+1), Epot_m_store(t_index+1), Epot_xb_store(t_index+1), Epot_titin_store(t_index+1)]; %Actin Epot, Myosin Epot, XB Epot, Titin Epot
                                        %(1e21)* converts N*m to units pn*nm
Epot_IntSprings_data(t_index+1, 5) = sum(Epot_IntSprings_data(t_index+1, 1:4)); %column 5: sum of internal Epots

Epot_IntExtSprings_data(t_index+1, 1:2) = [Epot_IntSprings_data(t_index+1, 5), Epot_ext_store(t_index+1)];
%================================================================================================================
%Output: Store fraction of cross-bridges bound at the end of each timestep
FracXbBound(t_index, 1) = sum(xb_state > 1)/m_nodes;
FracXb2(t_index) = sum(xb_state == 2)/m_nodes;
FracXb3(t_index) = sum(xb_state == 3)/m_nodes;


%Output: Store timestep data for this timestep

% Time and time storage updates (final update before end of timestep)
dt_store(t_index) = dt; %store dt value used in this timestep's calculations
% if dt == 0
%     pause
% end


%================================================================================================================
t(t_index + 1) = t(t_index) + dt; %update time vector with current time
t_index = t_index + 1; %increment time index

%Track when the time reaches an integer value of the units of dt i.e. 1 us, 1 ms, or 1 s for dt = 1e-6 s, dt = 1e-3 s, and dt = 1 s respectively
if display_code_runtime == true
    if mod(t_index, 1/dt_max) == 0
%        fprintf('Current t = %f for n = %i. Code runtime = %f s  \n', t(t_index), sim_counter, toc(timerVal_cycle));
    end
end

end % end of contraction cycle loop

t_end_true = t(t_index-1);
t_end_true_store(totalSimCounter) = t_end_true;



%% Outputs for Contraction Cycle
   
% AVERAGE FORCE (pN)
% avg_F_output = sum(F_output)/t(tot_timesteps-1);
avg_F_output = sum(F_output(1:tot_timesteps-1).*(dt_store./t_end_true));
avg_F_output_store(1, totalSimCounter) = avg_F_output;
%Average force (pN) as calculated at the spring proximal to the M-line
avg_F_output_mline = sum(F_output_mline(1:tot_timesteps-1).*(dt_store./t_end_true));
avg_F_output_mline_store(1, totalSimCounter) = avg_F_output_mline;

% FORCE VECTOR STORAGE (pN)
% F_output_store(sim_counter, :) = F_output;


% VARIANCE AND STANDARD DEVIATION OF FORCE
% F_std_store(1, sim_counter) = sqrt(sum((F_output(1:tot_timesteps-1) - avg_F_output).^2.*(dt_store./t_end_true)));
% F_var_store(1, sim_counter) = sum((F_output(1:tot_timesteps-1) - avg_F_output).^2.*(dt_store./t_end_true));
F_std_store(1, sim_counter) = std(F_output(1:tot_timesteps-1), dt_store);
F_var_store(1, sim_counter) = var(F_output(1:tot_timesteps-1), dt_store);
F_var_Norm2Peak_store(1, sim_counter) = var(F_output(1:tot_timesteps-1), dt_store)/max(F_output); %only really works for one myosin-one actin system
F_var_Norm2Avg_store(1, sim_counter) = var(F_output(1:tot_timesteps-1), dt_store)/avg_F_output;

xb_conn_comb_K = [xb_conn_free xb_conn_bound];
    [~, sort_ck_temp] = sort(xb_conn_comb_K(2,:)); %sort myosin nodes in ascending order
    xb_conn_comb_K = xb_conn_comb_K(:, sort_ck_temp); %sort entire matrix using the sorting indices of myosin
    xb_conn_comb_K(1, xb_state == 1) = 0; %second row contains all possible XB indices (m1 - mn), first row is (0) when unbound or (an = actin index) when bound
    xb_conn_K = xb_conn_comb_K; %rename as xb_conn_K

% AVERAGE FORCE WHILE EXT FORCE APPLIED
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %Force outputs while external force is applied
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % t_index_appforce = find(t > t_appforce, 1, 'first');
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % t_index_removeforce = find(t < t_removeforce, 1, 'last') + 1;
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % if t_index_removeforce >= tot_timesteps
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %         t_index_removeforce = tot_timesteps-1;
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % end

% F_output_appforce = F_output(t_index_appforce:t_index_removeforce);
% F_output_appforce_data(sim_counter, 1) = sum(F_output_appforce.*(dt_store(t_index_appforce:t_index_removeforce)./t_end_true));
% F_output_appforce_data(sim_counter, 2) = std(F_output_appforce, dt_store(t_index_appforce:t_index_removeforce));
    
% CORRELATION FUNCTION
if correlation_func ==  true
%%{
%Discretize Force output vector
% F_output = repmat([0, 0, 3], 1, (tot_timesteps-1)/3);
t_Fvar_incr = min(dt_store)/3; %/1e6; %min(dt_store); %0.0001;
% t_Fvar_incr = 1e-3; %testing
t_Fvar_corr = 0:t_Fvar_incr:t_end_true;
% t_Fvar_corr = t(2):t_Fvar_incr:t_end_true;
t_Fvar_bins = discretize(t_Fvar_corr, t);
% t_Fvar_bins = discretize(t_Fvar_corr, t(2:end));
Fvec_corr = F_output(t_Fvar_bins);

Tot_Tau = 0.04; %total Tau in seconds
Taumax = floor(0.04/t_Fvar_incr);
% Taumax = 500; %testing
for Tau = 0:Taumax
    %method (1)
    clear Fvar_corr_store
        for i = 1:length(t_Fvar_bins)-Tau
                Fvar_corr_store(i) = Fvec_corr(i)*Fvec_corr(i+Tau);
        end

    %method (2)
%     Fvar_corr_store(1:length(t_Fvar_bins)-Tau) = Fvec_corr(1:length(t_Fvar_bins)-Tau).*Fvec_corr(1+Tau:length(t_Fvar_bins));
    
    %method (1 and 2)
    mean_Fvar_corr_store(Tau+1) = mean(Fvar_corr_store)-(avg_F_output)^2;
    
    %method(3) must comment out 'clear' statement above
%     Fvar_corr_store(Tau+1, 1:length(t_Fvar_bins)-Tau) = Fvec_corr(1:length(t_Fvar_bins)-Tau).*Fvec_corr(1+Tau:length(t_Fvar_bins));
end

%method (3)
% mean_Fvar_corr_store = mean(Fvar_corr_store, 2).' .- (avg_F_output)^2;

mean_Fvar_corr_T0_store(sim_counter) = mean_Fvar_corr_store(1);
Tau_x = [0:Taumax]*t_Fvar_incr;
%{
clear Taupeaks
% Taupeaks(:, 1) = Tau_x(mean_Fvar_corr_store > max(mean_Fvar_corr_store)/10);
% [Taupeaks(:, 2), Taupeaks_index] = findpeaks(mean_Fvar_corr_store, 'MinPeakHeight', 0.01); 
[Taupeaks(:, 2), Taupeaks_index] = findpeaks(mean_Fvar_corr_store, 'MinPeakProminence', 0.03);
Taupeaks(:, 1) = Tau_x(Taupeaks_index);
Taupeaks(2:length(Taupeaks)+1, :) = Taupeaks;
Taupeaks(1,1) = 0;
Taupeaks(1, 2) = mean_Fvar_corr_store(1);
TP_exp = fit(Taupeaks(:, 1), Taupeaks(:, 2), 'exp1');
TP_time_const = -1/TP_exp.b;
TP_exp_eqn = ['y = ', num2str(TP_exp.a), 'exp(', num2str(TP_exp.b), 'x)', newline, 'Time const = ', num2str(TP_time_const), ' s'];
%}

% close Figure 20
figure(20) %all correlation points
% subplot(2, 2, sim_counter)
    plot(Tau_x, mean_Fvar_corr_store, '-ko', 'MarkerSize', 3);
%     plot([1:Taumax], mean_Fvar_corr_store, 'k.');
    hold on
    xlabel(['Tau (s)*']); %, num2str(t_Fvar_incr), ' s)']);
    ylabel('<f(t)f(t+T)> - <f>^2');
%     text(0.5*Tau, 0.8*max(mean_Fvar_corr_store), ['Avg. Corr. = ', num2str(mean(mean_Fvar_corr_store), '%.3e')], 'FontSize', 9, 'Color', 'k');
    %characteristic Tau text ~ 0.63*max var (at Tau = 0)
    title(['Correlation of Force with Tau_{max} = ', num2str(Tau)]);

%{
figure(21) %only correlation peaks
subplot(2, 2, sim_counter)
    plot(Taupeaks(:,1), Taupeaks(:, 2), 'ko', 'MarkerSize', 3);
    hold on
    plot(TP_exp);
    hold on
    xlabel(['Tau (s)']);
    ylabel('<f(t)f(t+T)> - <f>^2');
    ylim([0, mean_Fvar_corr_store(1)*1.1]);%(max(Taupeaks(:, 2))*1.1));
    title(['Correlation of Force with Tau_{max} = ', num2str(Tau), ' (Peaks only)']);
    text(max(Taupeaks(:,1)*0.5), max(Taupeaks(:,2)*0.75), TP_exp_eqn, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%}   
%} 
end

% Store values needed for correlation_function
if save_data_for_corr_func == true
    F_output_corr(sim_counter, :) = F_output;
    dt_store_corr(sim_counter, :) = dt_store;
    t_corr(sim_counter, :) = t;
end

% AVERAGE TIME PER CYCLE FOR 3.11 SYSTEM
if m_nodes == 1
    t_cycle_indices = [t_Ca+1, (find((diff(N_states(:, a_nodes+2)) == -2))+1).'];
    t_cycle_store = t(t_cycle_indices);
    % t_cycle_store(1:length(t_cycle_store) + 1) = [t(t_Ca+1), t_cycle_store];
    t_cycle_times = diff(t_cycle_store);
    t_cycle_avg = mean(t_cycle_times);
    t_cycle_median = median(t_cycle_times);
    t_cycle_avg_store(sim_counter) = t_cycle_avg;
    t_cycle_median_store(sim_counter) = t_cycle_median;
else
% AVERAGE TIME PER CYCLE FOR MULTIPLE MYOSIN SYSTEM
    for m = 1:m_nodes
        t_cycle_indices = [t_Ca+1, (find((diff(N_states(:, a_nodes+1+m)) == -2))+1).']; 
        t_cycle_store = t(t_cycle_indices);
        t_cycle_times = diff(t_cycle_store);
        t_cycle_avg = mean(t_cycle_times);
        t_cycle_median = median(t_cycle_times);
        t_cycle_avg_store(sim_counter, m) = t_cycle_avg;
        t_cycle_median_store(sim_counter, m) = t_cycle_median;
    end
end



% AVG FORCE PER 1 XB CYCLE
%    F_per_cycle = sum(F_output)/sum(ATPase_tracker); %/mean(avg_res_times(:,3));
for m = 1:m_nodes
   sum_F_ea_m(m) = sum(F_output((xb_trans_store(:,m) == -2)));
end
F_per_cycle = sum(sum_F_ea_m)/sum(ATPase_tracker);
F_per_cycle_store(1, sim_counter) = F_per_cycle;

% TOTAL ATP CONSUMED/TIME (ATP consumed/s)
% ATP_per_time = sum(ATPase_tracker)/((tot_timesteps-1)*dt);
ATP_per_time = sum(ATPase_tracker)/t_end_true;
ATP_per_time_store(1, sim_counter) = ATP_per_time;
if t_end_true >= 2 + t(t_Ca) && t(t_Ca) < 2
    t_2s = find(t > 2+t(t_Ca), 1, 'first');
    ATP_per_time_2s = sum(ATPase_tracker(t_Ca:t_2s))/(t(t_2s)-t(t_Ca));
    ATP_per_time_2s_store(1, sim_counter) = ATP_per_time_2s;
end




% Calculate RMSE of ATPase activity
% Method (1)
if ATPase_interp == false
    %%{
    [coeff, S] = polyfit(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 1); %calculates 
    [ATPase_lr, delta] = polyval([coeff(1), coeff(2)], t, S); %ATPase_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
    if fix_ATPaselr_int == true
        % y-intercept fixed at origin (0,0)
        ATPase_lr_mdl = fitlm(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 'y~x1-1');
        ATPase_lr = t*(ATPase_lr_mdl.Coefficients.Estimate);
        RMSE_mdl_singlesim = ATPase_lr_mdl.RMSE;
        RMSE_mdl_ATP_store(1, sim_counter) = RMSE_mdl_singlesim;
    end
    if ATPase_RMSE_weighted == false
        RMSE_singlesim = sqrt(mean((ATPase_lr(1:tot_timesteps-1) - ATPase_tracker_plot(1:tot_timesteps-1)).^2, 'omitnan'));
    else
        RMSE_singlesim = sqrt(sum((ATPase_lr(1:tot_timesteps-1) - ATPase_tracker_plot(1:tot_timesteps-1)).^2.*(dt_store/t_end_true), 'omitnan'));
    end
        %}
% Method (2)
% Use interpolation function to assign output parameter to specified "tick marks" at smallest timestep.
    %slope of ATPase activity should be same, but RMSE should change due to introducing more points during longer timesteps
else
    %%{
    dt_min = min(dt_store);
    interp_time = 0:dt_min:t_end_true; %round(t_end_true/dt_min, 0);
    ATPase_tracker_plot_interp = interp1(t, ATPase_tracker_plot, interp_time);
    % y-intercept not fixed at origin (0,0)
    [coeff, S] = polyfit(interp_time, ATPase_tracker_plot_interp, 1); %calculates linear regression coeff using ATPase activity interpolated at time points corresponding to the smallest dt value in the simulation
    [ATPase_lr, delta] = polyval([coeff(1), coeff(2)], interp_time, S); %ATPase_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
    RMSE_singlesim = sqrt(mean((ATPase_lr - ATPase_tracker_plot_interp).^2, 'omitnan'));
    % RMSE_singlesim = sqrt(mean((ATPase_lr(1:tot_timesteps-1) - ATPase_tracker_plot(1:tot_timesteps-1)).^2.*(dt_store/t_end_true), 'omitnan'));
    %}
end

RMSE_ATP_store(1, totalSimCounter) = RMSE_singlesim;

% CUMULATIVE ATP CONSUMED FOR SIMULATION
ATP_total = sum(ATPase_tracker);
ATP_total_store(1, totalSimCounter) = ATP_total;
ATP_1s_total = sum(ATPase_tracker(t_Ca+1:find(t < 1, 1, 'last'))); %Amount of ATP consumed in the first second after start of simulation
ATP_1s_total_store(1, totalSimCounter) = ATP_1s_total;

% Mean Squared Regression of Cumulative ATPase Activity (Equation)
% Cum_ATPase_lr = fitlm([t.', ATPase_tracker_plot.']);

% Mean Residence Times (time (ms) spent in each state)
for m = 1:m_nodes %Add in check for NaN before doing it instead of size
    % Modify the m_res_times matrix such that times when we move reverse from state 3 to state 2 are not logged as time in state 3
    m_res_t_index_32 = find(xb_trans_store(:, m) == -1 & N_states(1:tot_timesteps-1, a_nodes+1+m) == 3); %identify t_index's of 3->2 transitions
%     [C, i_m_res, i_m_ind] = intersect(m_res_times, m_res_t_index_32); %C = m_res_times(i_m_res) [i_m_res are linear indices]
%     i_m_res_2 = [(i_m_res-1); (i_m_res)]; %linear indices of 3->2 transitions and the previous index of m_res_times
%     m_res_times(i_m_res_2) = NaN; %convert 3->2 transitions to NaN    
    if ~isempty(m_res_t_index_32)
        for j = 1:length(m_res_t_index_32)
            ind_mres_3to2(j) = find(m_res_times((m-1)*6+6, :) == m_res_t_index_32(j)); %find all indices in "out of 3" row associated with t_index of 3->2 transitions
        end
    else
        ind_mres_3to2 = [];
    end
    %can try to use exist function to see if ind_mres_3to2 exists and then proceed with next two lines %pickup 10/26/2021
    m_res_times((m-1)*6+5, ind_mres_3to2) = NaN; %convert "into 3" indices associated with 3-> 2 transitions for this myosin into NaN  
    m_res_times((m-1)*6+6, ind_mres_3to2) = NaN; %convert "out of 3" indices associated with 3-> 2 transitions for this myosin into NaN  
    clear ind_mres_3to2
    t_ind_into3 = m_res_times((m-1)*6+5, 1:find(m_res_times((m-1)*6+6,:), 1, 'last')); %extract row of transitions into 3
    t_ind_into3(isnan(t_ind_into3)) = []; %delete any NaN in this row
    t_ind_outof3 = m_res_times((m-1)*6+6,1:find(m_res_times((m-1)*6+6,:), 1, 'last')); %extract row of transitions out of 3
    t_ind_outof3(isnan(t_ind_outof3)) = []; %delete any NaN in this row
               
    %Find average of the difference between t_out and t_in for each state
        if ~isnan(m_res_times((m-1)*6+2, 1))
            avg_s1 = mean(t(m_res_times((m-1)*6+2,1:find(m_res_times((m-1)*6+2,:), 1, 'last'))) - t(m_res_times((m-1)*6+1, 1:find(m_res_times((m-1)*6+2,:), 1, 'last'))));
            avg_res_times(m,1) = avg_s1;
        end
        if ~isnan(m_res_times((m-1)*6+4, 1))
            avg_s2 = mean(t(m_res_times((m-1)*6+4,1:find(m_res_times((m-1)*6+4,:), 1, 'last'))) - t(m_res_times((m-1)*6+3, 1:find(m_res_times((m-1)*6+4,:), 1, 'last'))));
            avg_res_times(m,2) = avg_s2;
        end
        if ~isnan(m_res_times((m-1)*6+6, 1)) 
%             avg_s3 = mean(t(m_res_times((m-1)*6+6,1:find(m_res_times((m-1)*6+6,:), 1, 'last'))) - t(m_res_times((m-1)*6+5, 1:find(m_res_times((m-1)*6+6,:), 1, 'last'))));
            avg_s3 = mean(t(t_ind_outof3) - t(t_ind_into3)); %For when we ignore moving reverse from state 3 to state 2 i.e. this time in state 3 not logged as res time in state 3
            avg_res_times(m,3) = avg_s3;
        end
end



avg_res_times_store(:,:,sim_counter) = avg_res_times(:,:,1); %Calculated within loop; Code below


% DUTY RATIO (portion of time spent in state 3 relative to other states)
%Track number of ITERATIONS the myosin spend in each state to calculate duty ratio
for m = 1:m_nodes
%     myo_st_iterations(1,m) = sum(N_states((t_Ca+1):tot_timesteps, a_nodes+1+m) == 1);
%     myo_st_iterations(2,m) = sum(N_states((t_Ca+1):tot_timesteps, a_nodes+1+m) == 2);
%     myo_st_iterations(3,m) = sum(N_states((t_Ca+1):tot_timesteps, a_nodes+1+m) == 3);
    %Track number of SECONDS the myosin spend in each state to calculate duty ratio
% %     myo_st(1,m) = sum(dt_store(N_states((t_Ca+1):tot_timesteps, a_nodes+1+m) == 1)); %row: state, column: myosin number
% %     myo_st(2,m) = sum(dt_store(N_states((t_Ca+1):tot_timesteps, a_nodes+1+m) == 2));
% %     myo_st(3,m) = sum(dt_store(N_states((t_Ca+1):tot_timesteps, a_nodes+1+m) == 3));
    myo_st(1,m) = sum(dt_store(N_states(1:tot_timesteps-1, a_nodes+1+m) == 1)) - sum(dt_store(1:t_Ca)); %row: state, column: myosin number
    myo_st(2,m) = sum(dt_store(N_states(1:tot_timesteps-1, a_nodes+1+m) == 2));
    myo_st(3,m) = sum(dt_store(N_states(1:tot_timesteps-1, a_nodes+1+m) == 3));
%     myo_st(3,m) = sum(dt_store(N_states(1:tot_timesteps-1, a_nodes+1+m) == 3 & (xb_trans_store ~= -1))); %This line only counts time in state 3 that does not move backwards afterwards
    
end
avg_myo_st(sim_counter, 1) = mean(myo_st(1,:)); %Row: simulation number; column: avg time spent in state 1 (col. 1), state 2 (col. 2), and state 3 (col. 3)
avg_myo_st(sim_counter, 2) = mean(myo_st(2,:));
avg_myo_st(sim_counter, 3) = mean(myo_st(3,:));
%Calculate and store Duty Ratio for this stimulation
% duty_ratio = avg_myo_st(sim_counter, 3)/(tot_timesteps - t_Ca);
duty_ratio = avg_myo_st(sim_counter, 3)/(t(tot_timesteps) - t(t_Ca));
DR_st1 = avg_myo_st(sim_counter, 1)/(t(tot_timesteps) - t(t_Ca));
DR_st2 = avg_myo_st(sim_counter, 2)/(t(tot_timesteps) - t(t_Ca));
duty_ratio_store(1, sim_counter) = duty_ratio;
DR_st1_store(1, sim_counter) = DR_st1;
DR_st2_store(1, sim_counter) = DR_st2;
%Store myosin state counts for this simulation
myo_st_store(:, :, sim_counter) = myo_st(:, :, 1);
%Calculate duty ratio for each myosin in 2 myosin system
% duty_ratio_1 = myo_st(3,1)/(tot_timesteps - t_Ca); %myosin 1
% duty_ratio_2 = myo_st(3,2)/(tot_timesteps - t_Ca); %myosin 2
%Store duty ratio of each myosin node in 2 myosin system
% DR1_store(pe_counter1, pe_counter2) = duty_ratio_1;
% DR2_store(pe_counter1, pe_counter2) = duty_ratio_2;
% DR1_store(sim_counter) = duty_ratio_1;
% DR2_store(sim_counter) = duty_ratio_2;

% AVERAGE WORK/ATP (J/ATP)
avg_work_per_ATP = sum(work_store)/sum(ATPase_tracker);
avg_work_per_ATP_store(1, sim_counter) = avg_work_per_ATP;
total_work = sum(work_store);
total_work_store(1, sim_counter) = total_work;

% WORK
% k_eff = (F_output.^2)./(work_store.'*(duty_ratio^2));
% % For 1 myosin 1 actin system, test case 1, k_eff is always the same
% % k_eff_overall = mean(k_eff(~isinf(k_eff) & ~isnan(k_eff)));
% k_eff_overall = mean(k_eff(isfinite(k_eff)));
% k_eff_overall_store(1, sim_counter) = k_eff_overall;
% % work_est = F_output(1, t_index)^2
% if m_nodes == 1
%     k_eff_23 = (F_output(N_states(:,a_nodes+2) == 3)).^2./(work_store(N_states(:,a_nodes+2) == 3).'*(duty_ratio^2));
%     k_eff_23_overall = mean(k_eff_23(isfinite(k_eff_23)));
%     k_eff_23_overall_store(1, sim_counter) = k_eff_23_overall; % PICKUP
% end

% POTENTIAL ENERGY - Characteristic time of fluctuations
% Calculate Characteristic Time (Tau) of fluctuations by tracking whenever the E_pot drops (cliff) (inverse of a spike)
E_potential_ext_T1 = E_potential_ext(1:end-1);
E_potential_ext_T2 = E_potential_ext(2:end);
n_cliffs = sum(E_potential_ext_T2 > E_potential_ext_T1);
t_char_fluc_store(1, sim_counter) = t_end_true/n_cliffs;


% Display output values
%{
fprintf('For simulation %i of %i: \n', sim_counter, n_sim);

fprintf('End Time = %f s \n', t_end_true);

fprintf('Duty Ratio = %f  \n', duty_ratio);
% fprintf('Duty Ratio1 = %f  \n', duty_ratio_1);
% fprintf('Duty Ratio2 = %f  \n', duty_ratio_2);
% fprintf('Average State 1 Residence Time = %f ms \n', mean(avg_res_times(:, 1)));
% fprintf('Average State 2 Residence Time = %f ms \n', mean(avg_res_times(:, 2)));
% fprintf('Average State 3 Residence Time = %f ms \n', mean(avg_res_times(:, 3)));

fprintf('Avg. Force = %f pN \n', avg_F_output);
% if m_nodes == 1
   fprintf('Avg. Force per Cycle = %f pN \n',F_per_cycle); 
% end

fprintf('Avg. Cycle Time = %f s \n', t_cycle_avg);

fprintf('Total ATP Consumed = %i molecules (t = %2f s) \n', ATP_total, t_end_true);
fprintf('ATP/s = %f ATP/s \n', ATP_per_time);
fprintf('RMSE of ATP/s = %f ATP \n', RMSE_ATP_store(1, sim_counter));
if t_end_true >= 2
    fprintf('ATP/s (first 2s) = %f ATP/s \n', ATP_per_time_2s);
end

for i = 1:m_nodes
    fprintf('ATP Consumed by m%i = %i molecules (total time = %1f s) \n', i, ATPase_ea_m(i), t_end_true);
end

fprintf('Total Work = %s J (t = %2f s) \n', total_work, t_end_true);
fprintf('Avg. Work/ATP = %s J/ATP \n', avg_work_per_ATP);
% fprintf('K_eff = %f  \n', k_eff_overall); %the effective spring constant of the system for a 1 myosin 1 actin system

fprintf('--------------------------------------------------------------- \n');
%}

%% UPDATE STORAGE ARRAYS FOR OUTPUTS ACROSS SIMULATIONS
% Find minimum t_end_store 
% t_end_true_min = min(t_end_true_store); %only going to discretize to the minimum true time of all simulations run
% if t_end_true > 1 %prevents t_end_true values of less than 1 s from being stored
    t_end_true_min = min(t_end_true_store);
% end
%%{
%Discretize force vector into small time bins (t_F_bin_s) <- values used again for Epot and M-line displacement, standard: 1e-3s
t_F_bin_s = 1e-3; 
t_F_edges = 0:t_F_bin_s:t_end_true_min; %what are the bin edges you want to average the forces in between
n_F_edges = length(t_F_edges); %what is the minimum number of bin edges we are looking at across all simulations run
ind_F_bin = discretize(t_F_edges, t); %what bin (i.e. indicies of time points in t) within t each value of t_F_edges falls into

if n_F_edges > length(F_outputTotalSims)
    t_F_bin_s = t_end_true_min/(length(F_outputTotalSims)-1); %F_outputTotalSims is preallocated at 1e8 
    t_F_edges = 0:t_F_bin_s:t_end_true_min; %what are the bin edges you want to average the forces in between
    n_F_edges = length(t_F_edges); %what is the minimum number of bin edges we are looking at across all simulations run
    ind_F_bin = discretize(t_F_edges, t); %what bin (i.e. indicies of time points in t) within t each value of t_F_edges falls into
end


% Discretize force vector into small time bins (t_F_bin_s) Method 2 (correct)
clear F_discr
i = 1; %initialize i; ind_F_bin(i) = index of t at the end of each bin
while i <= n_F_edges-1 %Go through and take the average of the forces within each bin 
    ind_span2 = ind_F_bin(i):ind_F_bin(i+1);
    clear F_v1 F_v2
    for j = 1:length(ind_span2)
        F_v1(j) = min([t_F_edges(i+1), t(ind_span2(j)+1)]);
        F_v2(j) = max([t_F_edges(i), t(ind_span2(j))]);
    end
    F_v0 = F_output(ind_span2);
    F_discr(i) = sum(F_v0.*((F_v1 - F_v2)./t_F_bin_s)); %time weighted average force over the above indices in ind_span2
    i = i+1;
end

%Sum all of F_outputs from all simulations --> increasing the # of simulations simulates increasing # of sarcomeres
%producing force with each other
%*The variance we see in force should decrease with increasing number of simulations

F_outputTotalSims(i:end) = []; %remove any forces from previous simulations that are at greater times than minimum of all t_end_true of sims run
                               %note that i was incremented one final time before the end of the while loop above
F_outputTotalSims = F_outputTotalSims + F_discr;
%}
%================================================================================================================
% Store the F_output from each Sim - for use with Tau calculations. Can then run various std_mult values on the same set of data
F_discrEaSim_store(totalSimCounter, 1:n_F_edges-1) = F_discr;
F_outputRawEaSim_store(totalSimCounter, :) = F_output;
dt_EaSim_store(totalSimCounter,:) = dt_store;
t_EaSim_store(totalSimCounter,:) = t;

%================================================================================================================
%Find time intervals of changes in force (changes = when it varies between +- 1 standard deviation from mean)
%Calculate for each simulation, then get avg and standard deviation of n sims
% final5 = 0.5; %Find values over the final 0.5 seconds of the simulation
% std_mult = 0.5; %multiplier to standard deviation 
% t_ind_final5 = find(t > (t_end_true - final5), 1, 'first');
% avg_F_op_5 = sum(F_output(t_ind_final5:(tot_timesteps-1)).*(dt_store(t_ind_final5:end)./final5));
% std_F_op_5 = std_mult*std(F_output(t_ind_final5:(tot_timesteps-1)), dt_store(t_ind_final5:end)); %can also check within the range of 0.5*std
% ind_above = (t_ind_final5-1) + find(F_output(t_ind_final5:tot_timesteps-1) > (avg_F_op_5 + std_F_op_5));
% ind_below = (t_ind_final5-1) + find(F_output(t_ind_final5:tot_timesteps-1) < (avg_F_op_5 - std_F_op_5));
% [ind_ab_start, I] = min([min(ind_above), min(ind_below)]); %find the starting index of the first value within std F of mean F
% [~, I_max] = max([max(ind_above), max(ind_below)]); %find whether the final index lies above or below the mean
% if I_max == 1 %final index is above the mean
%    ind_ab_end = ind_above(find(ind_above > max(ind_below), 1, 'first'));
% else %final index is below the mean
%    ind_ab_end = ind_below(find(ind_below > max(ind_above), 1, 'first'));
% end
% %Prep for finding indices and times of =- std F
% clear ind_ab_store t_ab_store
% ind_ab_store(1) = ind_ab_start; %initialize index array
% t_ab_store(1) = t(ind_ab_start); %initialize time array
% I = I+1;
% i = 2;
% ind_ab_temp = 0;
% while true
%    switch mod(I, 2)
%        case 1 %look at vector of values ABOVE mean by 1 standard deviation
%            ind_ab_temp = ind_above(find(ind_above > ind_ab_store(i-1), 1, 'first')); %next highest index in the "mean F + std F" group
%        case 0 %look at vector of values BELOW mean by 1 standard deviation
%            ind_ab_temp = ind_below(find(ind_below > ind_ab_store(i-1), 1, 'first')); %next highest index in the "mean F - std F" group
%    end
%    ind_ab_store(i) = ind_ab_temp; %update index array
%    t_ab_store(i) = t(ind_ab_temp); %update time array
%    i = i+1;
%    I = I+1;
%    if ind_ab_temp == ind_ab_end %end when you get to the final switch to above or below mean F
%        break
%    end
% end
% %Outputs - Store average time of +- standard deviation switch time interval - make exception in clearvars
% t_ab_intervals = diff(t_ab_store); %find duration of the intervals between mean F +- std F
% t_ab_int_df(1, totalSimCounter) = mean(t_ab_intervals); %mean in row 1
% t_ab_int_df(2, totalSimCounter) = std(t_ab_intervals); %std in row 2
% F_ab_intervals = diff(F_output(ind_ab_store)); %differences in force between mean F +- std F time points
% F_ab_int_df(1, totalSimCounter) = mean(F_ab_intervals);
% F_ab_int_df(2, totalSimCounter) = std(F_ab_intervals);
%================================================================================================================
%Find time intervals of changes in force (changes = when it varies between +- 1 standard deviation from mean)
%Calculate for each simulation, then get avg and standard deviation of n sims
% if t_end_true > 9.3
%     final19 = 9; %Find values over the last final19 seconds
%     std_mult = 0.25; %multiplier to standard deviation 
%     t_ind_final19 = find(t > (t_end_true - final19), 1, 'first');
%     avg_F_op_5 = sum(F_output(t_ind_final19:(tot_timesteps-1)).*(dt_store(t_ind_final19:end)./final19));
%     std_F_op_5 = std_mult*std(F_output(t_ind_final19:(tot_timesteps-1)), dt_store(t_ind_final19:end)); %can also check within the range of 0.5*std
%     ind_above = (t_ind_final19-1) + find(F_output(t_ind_final19:tot_timesteps-1) > (avg_F_op_5 + std_F_op_5));
%     ind_below = (t_ind_final19-1) + find(F_output(t_ind_final19:tot_timesteps-1) < (avg_F_op_5 - std_F_op_5));
%     [ind_ab_start, I] = min([min(ind_above), min(ind_below)]); %find the starting index of the first value within std F of mean F
%     [~, I_max] = max([max(ind_above), max(ind_below)]); %find whether the final index lies above or below the mean
%     if I_max == 1 %final index is above the mean
%        ind_ab_end = ind_above(find(ind_above > max(ind_below), 1, 'first'));
%     else %final index is below the mean
%        ind_ab_end = ind_below(find(ind_below > max(ind_above), 1, 'first'));
%     end
%     %Prep for finding indices and times of =- std F
%     clear ind_ab_store t_ab_store
%     ind_ab_store(1) = ind_ab_start; %initialize index array
%     t_ab_store(1) = t(ind_ab_start); %initialize time array
%     I = I+1;
%     i = 2;
%     ind_ab_temp = 0;
%     while true
%        switch mod(I, 2)
%            case 1 %look at vector of values ABOVE mean by 1 standard deviation
%                ind_ab_temp = ind_above(find(ind_above > ind_ab_store(i-1), 1, 'first')); %next highest index in the "mean F + std F" group
%            case 0 %look at vector of values BELOW mean by 1 standard deviation
%                ind_ab_temp = ind_below(find(ind_below > ind_ab_store(i-1), 1, 'first')); %next highest index in the "mean F - std F" group
%        end
%        ind_ab_store(i) = ind_ab_temp; %update index array
%        t_ab_store(i) = t(ind_ab_temp); %update time array
%        i = i+1;
%        I = I+1;
%        if ind_ab_temp == ind_ab_end %end when you get to the final switch to above or below mean F
%            break
%        end
%     end
%     %Outputs - Store average time of +- standard deviation switch time interval - make exception in clearvars
%     t_ab_intervals_long = diff(t_ab_store); %find duration of the intervals between mean F +- std F
%     t_ab_int_long_df(1, totalSimCounter) = mean(t_ab_intervals_long); %mean in row 1
%     t_ab_int_long_df(2, totalSimCounter) = std(t_ab_intervals_long); %std in row 2
%     
%     
%     
% end

if startNextSim_from_GeomPrev == true
       t_ab_intervals_long_TotalSims = [t_ab_intervals_long_TotalSims, t_ab_intervals]; %t_ab_intervals_long];
       N_locInitial_from_GeomPrev = N_locations(tot_timesteps, :);
       N_statesInitial_from_GeomPrev = N_states(tot_timesteps, :);
       xb_conn_bound_from_GeomPrev = xb_conn_bound;
end
%================================================================================================================

%Repeat for ATP consumption using the same discretization parameters used to discretize force (method 1)
%{
for j = 1:length(ind_span)%-1
%     jj = j+1;
    ATP_v1(j) = min([t_F_edges(i+1), t(ind_span(j))]);
    ATP_v2(j) = max([t_F_edges(i), t(ind_span(j)-1)]);
end
% ind_span2 = ind_F_bin(i):ind_F_bin(i+1)-1;
if ind_span(1) == 1 %for beginning edge case, ind_span = [1, 2]
    ATP_v0 = ATPase_tracker(ind_span(1:end-1));
    ATP_v3 = t(ind_span) - [0, t(ind_span(2:end))];
else
    ATP_v0 = ATPase_tracker(ind_span-1);
    ATP_v3 = t(ind_span) - t(ind_span-1);
end
%}
%================================================================================================================
% Discretize ATP consumption vector into small time bins (t_F_bin_s) method 2 (correct)
%edge cases
%end of bin: want the minimum between the end of the discretized time bin (t_F_edges(i+1)) and and the final t value of the vector t(ind_span)
% ATP_v1 = min([t_F_edges(i+1), t(ind_F_bin(i+1))]);
%start of bin: want the maximum between the start of the discretized time bin (t_F_edges(i)) and the first t value of the vector t(ind_span)
% ATP_v2 = max([t_F_edges(i), t(ind_F_bin(i))]);

%Create generalized vectors of the above two terms for all of the values in t(ind_span)
%REDO the above with new ind_span such that ind_span2 = ind_F_bin(i):ind_F_bin(i+1)-1;
clear ATP_discr
i = 1; %initialize i; ind_F_bin(i) = index of t at the end of each bin
v3_zerocount = 0;
while i <= n_F_edges-1 %Go through and take the average of the ATP consumption within each bin 
    ind_span2 = ind_F_bin(i):ind_F_bin(i+1);
    clear ATP_v1 ATP_v2
    for j = 1:length(ind_span2)
        ATP_v1(j) = min([t_F_edges(i+1), t(ind_span2(j)+1)]);
        ATP_v2(j) = max([t_F_edges(i), t(ind_span2(j))]);
    end
    ATP_v0 = ATPase_tracker(ind_span2);
    ATP_v3 = t(ind_span2+1) - t(ind_span2);
%     ATP_v32 = vpa(vpa(t(ind_span2+1), 64) - vpa(t(ind_span2), 64), 64);
%     ATP_v3_store{sim_counter, i} = ATP_v3;
%     ATP_v32_store{sim_counter, i} = ATP_v32;
%     if ~all(ATP_v3)
%        ATP_v3 = 
%        v3_zerocount = v3_zerocount + 1;
%     end
    ATP_discr(i) = sum(ATP_v0.*((ATP_v1 - ATP_v2)./ATP_v3), 'omitnan');
%     ATP_discr2(i) = sum(ATP_v0.*((ATP_v1 - ATP_v2)./ATP_v32));
%     if isnan(ATP_discr(i))
%         pause
%     end
    i = i+1;
end
ATP_discr_cum = cumsum(ATP_discr);
% ATP_discr_cum2 = cumsum(ATP_discr2);

% Sum of all ATP consumption from all simulations
% ATPase ACTIVITY STORAGE
% ATP_discr_store(totalSimCounter, :) = ATP_discr_cum;
ATPase_trackerTotalSims(i:end) = []; %remove any ATPase from previous simulations that are at greater times than minimum of all t_end_true of sims run
                                     %note that i was incremented one final time before the end of the while loop above
ATPase_trackerTotalSims = ATPase_trackerTotalSims + ATP_discr_cum;
%================================================================================================================
% Store the ATPase from each Sim
ATPase_discr_cum_store(totalSimCounter, 1:n_F_edges-1) = ATP_discr_cum; %Store each simulation's discretized ATP consumption
ATPase_tracker_plot_eaSim_store(totalSimCounter, :) = ATPase_tracker_plot;

%================================================================================================================
% Store discretized moving average ATP consumption vectors for each simulation
% aATP_period = round((n_F_edges/300),0); %variable value of aATP_period -> ~300 total points per graph
%                                         %n_F_edges is number of F_discr bin edges in F_discr calculation i.e. length (t_F_edges)
% aATP_t = t_F_edges_plot(aATP_period:aATP_period:length(t_F_edges_plot)); %actual time points at which to take average
% ATP_consumed_TotalSims = ATPase_trackerTotalSims(aATP_period:aATP_period:length(ATPase_trackerTotalSims))./aATP_t; 
%%{
t_ATP_bin_s = 20e-3; %interval size of spacing between green points of the moving average of ATP consumed/s
t_ATP_edges = [0:t_ATP_bin_s:t_end_true_min];
ATP_bin_counts = histcounts(t, t_ATP_edges);
ATP_consumed_movingAvg_eaSim = diff(ATPase_tracker_plot([1, cumsum(ATP_bin_counts)]))./diff(t([1, cumsum(ATP_bin_counts)]));
ATP_Cons_movAvg_eaSim_store(totalSimCounter, 1:length(ATP_bin_counts)) = ATP_consumed_movingAvg_eaSim;
%================================================================================================================
%Store Discretized Potential energy of external spring data
% Discretize Epot vector into small time bins (t_F_bin_s) Method 2 (correct)
clear Epot_discr
i = 1; %initialize i; ind_F_bin(i) = index of t at the end of each bin
while i <= n_F_edges-1 %Go through and take the average of the forces within each bin 
    ind_span2 = ind_F_bin(i):ind_F_bin(i+1);
    clear Epot_v1 Epot_v2
    for j = 1:length(ind_span2)
        Epot_v1(j) = min([t_F_edges(i+1), t(ind_span2(j)+1)]);
        Epot_v2(j) = max([t_F_edges(i), t(ind_span2(j))]);
    end
    Epot_v0 = Epot_data(ind_span2, 1).';
    Epot_discr(i) = sum(Epot_v0.*((Epot_v1 - Epot_v2)./t_F_bin_s)); %time weighted average force over the above indices in ind_span2
    i = i+1;
end

%================================================================================================================
%Store Discretized M-line displacement
clear Mline_discr
Mline_loc = N_locations(:, end).'*(1e9);
i = 1; %initialize i; ind_F_bin(i) = index of t at the end of each bin
while i <= n_F_edges-1 %Go through and take the average of the forces within each bin 
    ind_span2 = ind_F_bin(i):ind_F_bin(i+1);
    clear Mline_v1 Mline_v2
    for j = 1:length(ind_span2)
        Mline_v1(j) = min([t_F_edges(i+1), t(ind_span2(j)+1)]);
        Mline_v2(j) = max([t_F_edges(i), t(ind_span2(j))]);
    end
    Mline_v0 = Mline_loc(ind_span2);
    Mline_discr(i) = sum(Mline_v0.*((Mline_v1 - Mline_v2)./t_F_bin_s)); %time weighted average force over the above indices in ind_span2
    i = i+1;
end
%} 
%================================================================================================================
%F data storage -> save per sim to get avg. and std. over n = totalSimCounter
F_df_StorePerSim(1, totalSimCounter) = avg_F_output; %average F per sim
F_df_StorePerSim(2, totalSimCounter) = std(F_output(1:tot_timesteps-1), dt_store); %std F per sim
F_df_StorePerSim(3, totalSimCounter) = F_df_StorePerSim(2, totalSimCounter)/F_df_StorePerSim(1, totalSimCounter); % Percent fluctuation per sim (std/avg. F)

Fop_discr_store(totalSimCounter, 1:n_F_edges-1) = F_discr; %Store each simulation's discretized Force Output

%Plateau ATP/s data storage -> save per sim to get avg. and std. over n = totalSimCounter
% ATP_consumed_plotPerSim = ATPase_tracker_plot(1:20:tot_timesteps-1)./t(1:20:tot_timesteps-1);
% platStart_ATPConsPerSim = find(ATP_consumed_plotPerSim >= 0.98*max(ATP_consumed_plotPerSim), 1, 'first');
% plat_ATPCons_CurrentSim = mean(ATP_consumed_plotPerSim(platStart_ATPConsPerSim:end), 'omitnan');
% plat_ATPConsPerSim(1, totalSimCounter) = mean(ATP_consumed_plotPerSim(platStart_ATPConsPerSim:end), 'omitnan'); %Plateau ATP/s consumption per sim

ATP_consumed_plotPerSim = ATPase_tracker_plot(1:tot_timesteps-1)./t(1:tot_timesteps-1);
platStart_ATPConsPerSim = find(ATP_consumed_plotPerSim >= 0.98*max(ATP_consumed_plotPerSim), 1, 'first');
plat_ATPCons_CurrentSim = mean(ATP_consumed_plotPerSim(platStart_ATPConsPerSim:end), 'omitnan');
plat_ATPConsPerSim(1, totalSimCounter) = mean(ATP_consumed_plotPerSim(platStart_ATPConsPerSim:end), 'omitnan'); %Plateau ATP/s consumption per sim


%Epot data storage -> save per sim to get avg. and std. over n = totalSimCounter
Epot_discr_store(totalSimCounter, 1:n_F_edges-1) = Epot_discr;
Epot_IntSprings_Mean_store(1, totalSimCounter) = sum((Epot_IntSprings_data(1:tot_timesteps-1, 5).').*(dt_store./t_end_true));
Epot_IntSprings_Std_store(1, totalSimCounter) = std(Epot_IntSprings_data(1:tot_timesteps-1, 5).', dt_store);
Epot_ExtSpring_Mean_store(1, totalSimCounter) = sum((Epot_ext_store(1:tot_timesteps-1)).*(dt_store./t_end_true));
Epot_ExtSpring_Std_store(1, totalSimCounter) = std(Epot_ext_store(1:tot_timesteps-1), dt_store);



%M-line displacement storage -> save per sim to get avg. and std. over n = totalSimCounter
% Mline_discr_store(totalSimCounter, 1:n_F_edges-1) = Mline_discr;
%================================================================================================================


%% Alerts

% if totalSimCounter == 10
%     load handel
%     sound(y,Fs)
%     pause
%     disp('10');
% end
% 
% if totalSimCounter == 20
%     load handel
%     sound(y,Fs)
%     pause
%     disp('20');
% end
% 
% if totalSimCounter == 30
%     load handel
%     sound(y,Fs)
%     pause
%     disp('30');
% end
% 
% if totalSimCounter == 40
%     load handel
%     sound(y,Fs)
%     pause
%     disp('40');
% end

%Reset values to initial
t_Ca_counter = 0;
Ca_reg = 0;
if startNextSim_from_GeomPrev == true
   t_Ca_counter = t_Ca + 1;
   Ca_reg = 1;
end

%Track runtime when a simulation ends
if display_code_runtime == true
    fprintf('Simulation %i of %i completed at code runtime = %f s \n', sim_counter, n_sim, toc(timerVal_sim));   
end
fprintf('Total Sim Counter = %i \n', totalSimCounter);

%%{
if create_StTraj_plot == true

% Trajectory Plot Data
% Create two vectors that track the state trajectory of the single myosin head over time

% Vector for time (starts at t(t_Ca+1) and then repeats from there i.e. [t1, t2, t2, t3, t3, t4, t4, ..., t_end, t_end])
t_traj = [t(t_Ca+2:end); t(t_Ca+2:end)];
t_traj = t_traj(:);
t_traj = [t(t_Ca+1); t_traj];

% Vector for trajetory of states
xb_trans_store_traj = xb_trans_store(t_Ca+1:end, 1).';
if m_nodes ~=1
   xb_trans_store_traj = xb_trans_store(t_Ca+1:end, :).'; 
end
xb_trans_store_traj(xb_trans_store_traj == -2) = 1; %replace all -2 (3 -> 1) transitions with 1
xb_trans_store_traj(xb_trans_store_traj == 2) = -1; %replace all 2 (1 -> 3) transitions with -1

% Create vector of continuous state of myosin i.e. continue counting upwards instead of cycling 3 -> 1 at end of cycle
for m = 1:m_nodes
    st_curr = 1; %current state that counts up i.e. the second state 1 is 4 and the second state 2 is 5 and so on
    % st_cont(1:t_Ca) = 1;
    st_cont(m, 1) = 1; %stores the continuous value of the state of the myosin head i.e. 1, 2, 3, 4, 5, 4, 5, 6, etc
    for i = 1:length(xb_trans_store_traj)-1
        st_curr = st_curr + xb_trans_store_traj(m, i);
    %     st_cont(t_Ca+i) = st_curr;
        st_cont(m, i+1) = st_curr;
    end
end

if m_nodes <=2
if m_nodes == 2
   st_cont3D = st_cont;
   st_cont = sum(st_cont); %sum of the continuous states each myosin is in at each time point (sums each column and produces row vector)
end
% st_traj = [N_states(1:end-1, a_nodes+2).'; N_states(2:end, a_nodes+2).'];
% traj_data = [xb_trans_store(t_Ca+1:end,1), xb_trans_store_traj.', st_cont.'];
% traj_data = [xb_trans_store(t_Ca+1:end,1), xb_trans_store_traj.', st_cont.', N_states(t_Ca+1:end-1, a_nodes+2)];
% Vector for continuous trajectory of states of myosin (starts and repeats state 1 and then repeats from there ending with an additional repeat of final state i.e. [st1, st1, st2, st2, st3, st3,..., st_end, st_end, st_end])
st_traj = [st_cont; st_cont];
st_traj = [st_traj(:); st_cont(end)];
traj_plot = [t_traj, st_traj];

%For 3D trajectory plot
if m_nodes == 2
    st_traj3D_y = [st_cont3D(1,:); st_cont3D(1,:)];
    st_traj3D_y = [st_traj3D_y(:); st_traj3D_y(end)];
    st_traj3D_z = [st_cont3D(2,:); st_cont3D(2,:)];
    st_traj3D_z = [st_traj3D_z(:); st_traj3D_z(end)];
    traj_plot3d = [t_traj, st_traj3D_y, st_traj3D_z];
end

% CALCULATE LINEAR REGRESSION
% y-intercept not fixed
[coeff_traj, S] = polyfit(traj_plot(:,1), traj_plot(:,2), 1); %calculates fit line coefficients
% [traj_lr, delta] = polyval([coeff_traj(1), coeff_traj(2)], traj_plot(:,1), S); %traj_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
t_traj_lr = t(t_Ca+2:end);
[traj_lr, delta] = polyval([coeff_traj(1), coeff_traj(2)], t_traj_lr, S); %traj_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME) - model evaluated at nonrepeated values of t

%CALCULATE RMSE
% RMSE_traj = sqrt(sum((traj_lr - traj_plot(:,2)).^2, 'omitnan')/length(traj_lr)); %pickup [9/27/2021] does this need to be weighted? .*(dt_store/t_end_true)-- %when traj_lr is composed of repeated values for state progression (y axis)
RMSE_traj = sqrt(sum((traj_lr - st_cont).^2, 'omitnan')/length(traj_lr)); %%when traj_lr is composed of non-repeated values for state progression (y axis)) 

% if fix_trajlr_int == true
    % y-intercept fixed at origin (0,1)
%     traj_lr_mdl = fitlm(traj_plot(:,1), traj_plot(:,2), 'y~x1-1');
%     traj_lr = traj_plot(:,1)*(traj_lr_mdl.Coefficients.Estimate);
% end
traj_lr_text = sprintf('y = %.3fx + %.3f (black) \n RMSE_{raw} = %.2f \n RMSE_{cyc} = %.1f cycles', coeff_traj(1), coeff_traj(2), RMSE_traj, RMSE_traj/3); %Convert the equation into text - intercept = (0,0)            

%Plot State Trajectory
figure(300)
plot(traj_plot(:,1), traj_plot(:,2));
hold on
% plot(traj_plot(:,1), traj_lr, '--k', 'LineWidth', 0.5);
plot(t(t_Ca+2:end), traj_lr, '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
% set(gca,'YTickLabel',{'1','2','3'});
xlabel('time (s)');
ylabel('State Progression');
% set(gca, 'ytick', [1:3:(traj_plot(end, 2) + (3 - mod(traj_plot(end, 2), 3)) )]);
% set(gca, 'ytick', linspace(0, (traj_plot(end, 2) + (9 - mod(traj_plot(end, 2), 9))), 10));
title(['Trajectory of Myosin Head']);
% text(0.7*t_end_true, 0.3*traj_plot(end,2), traj_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot
text(0.6*t_end_true, 0.7*median(traj_plot(:,2)), traj_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot

%Plot State Trajectory inset
figure(301)
traj_span = 30; %make sure even number
% traj_start = find(N_states(floor((tot_timesteps-1)/2):end, a_nodes+2) == 1, 1, 'first');
% plot(traj_plot(traj_start+floor((tot_timesteps-1)/2)*2+1:traj_start+floor((tot_timesteps-1)/2)*2+1+40,1), traj_plot(traj_start+floor((tot_timesteps-1)/2)*2+1:traj_start+floor((tot_timesteps-1)/2)*2+1+40,2));
plot(traj_plot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+traj_span,1), traj_plot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+traj_span,2));
hold on
% plot(traj_plot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+30,1), traj_lr(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+30), '--k', 'LineWidth', 0.5);
% plot(t((((tot_timesteps-1)/2)+t_Ca+2):(((tot_timesteps-1)/2)+traj_span)+t_Ca+2), traj_lr(((tot_timesteps-1)/2):((tot_timesteps-1)/2+traj_span)), '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
plot(t_traj_lr((ceil(length(t_traj_lr)/2)):(ceil(length(t_traj_lr)/2)+traj_span/2)), traj_lr(((tot_timesteps-1)/2):((tot_timesteps-1)/2+traj_span/2)), '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
% set(gca,'YTickLabel',{'1','2','3'});
ylim([floor(traj_plot(((tot_timesteps-1)/2)*2, 2))-2, floor(traj_plot(((tot_timesteps-1)/2)*2, 2)) + 16]);
xlabel('time (s)');
ylabel('State Progression');
title('Trajectory of Myosin Head');

if m_nodes == 2
    % 3D trajectory plot regression line (from https://www.mathworks.com/matlabcentral/answers/424591-3d-best-fit-line)
    traj_plot3d_trans = traj_plot3d.'; %3x12000 matrix
    traj_plot3d_mean = mean(traj_plot3d_trans, 2); %3x1 vector of means of t, y, and z
    tp3d_A = traj_plot3d_trans - traj_plot3d_mean;
    [U,S,~] = svd(tp3d_A);
    d_tp3d = U(:,1);
    t_tp3d = d_tp3d'*tp3d_A;
    traj_plot3d_trans_line = traj_plot3d_mean + [min(t_tp3d), max(t_tp3d)].*d_tp3d; %contains the two 3D points for line of best fit
    %Parametric equation of line: tp3D_trans_line = P*tp3D_trans_line(:,1) + (1-P)*tp3D_trans_line(:,2) where P is a real parameter?
%     eqns = [x(P) == traj_plot3d_trans_line(1,1) + (traj_plot3d_trans_line(1,2)-traj_plot3d_trans_line(1,1))*P; ...
%            [y(P) == traj_plot3d_trans_line(2,1) + (traj_plot3d_trans_line(2,2)-traj_plot3d_trans_line(2,1))*P; ...
%            [z(P) == traj_plot3d_trans_line(3,1) + (traj_plot3d_trans_line(3,2)-traj_plot3d_trans_line(3,1))*P];
%     r(P) = traj_plot3d_trans_line(:,1) + P*(traj_plot3d_trans_line(:,2)-traj_plot3d_trans_line(:,1));
    traj_unitvec = (traj_plot3d_trans_line(:,2)-traj_plot3d_trans_line(:,1))/norm(traj_plot3d_trans_line(:,2)-traj_plot3d_trans_line(:,1));
    traj3d_lr_text = sprintf('r(P) = <%.2f, %.2f, %.2f> + P*<%.2e, %.2f, %.2f>', traj_plot3d_trans_line(1,1), traj_plot3d_trans_line(2,1), traj_plot3d_trans_line(3,1),...
                                                                                 traj_unitvec(1), traj_unitvec(2), traj_unitvec(3));             

    
    figure(303)
    plot3(traj_plot3d(:,1), traj_plot3d(:,2), traj_plot3d(:,3));
    hold on
    plot3(traj_plot3d_trans_line(1,:), traj_plot3d_trans_line(2,:), traj_plot3d_trans_line(3,:), 'r');
    grid on
    xlabel('time (s)');
    ylabel('State Progression (m1)');
    zlabel('State Progression (m2)');
    title('Trajectory of Myosin Heads');
    text(0.3*t_end_true, 1.6*median(traj_plot3d(:,2)), 1.25*median(traj_plot3d(:,3)), traj3d_lr_text, 'FontSize', 9, 'Color', 'k'); %Insert the regression equation into the plot
end

else %- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    
%Remaining cases where m_nodes is not <= 2
%Want to create plot that tracks each individual myosin's path through all the states as different trajectory traces
% Vector for continuous trajectory of states of myosin (starts and repeats state 1 and then repeats from there ending with an additional repeat of final state i.e. [st1, st1, st2, st2, st3, st3,..., st_end, st_end, st_end])
for m = 1:m_nodes
    st_traj_temp = [st_cont(m,:); st_cont(m,:)];
    st_traj_temp = [st_traj_temp(:); st_cont(m, end)];
    st_traj(m, :) = st_traj_temp;
end

%Plot State Trajectory
turbo3CM = turbo(m_nodes);

% figure(304)
% for m = 1:m_nodes
% plot(t_traj, st_traj(m, :), "Linewidth", 1, 'Color', turbo3CM(m, :), 'DisplayName', ['myosin ', num2str(m)]);
% hold on
% end
% xlabel('time (s)');
% ylabel('State Progression');
% % set(gca, 'ytick', [1:3:(traj_plot(end, 2) + (3 - mod(traj_plot(end, 2), 3)) )]);
% % set(gca, 'ytick', linspace(0, (traj_plot(end, 2) + (9 - mod(traj_plot(end, 2), 9))), 10));
% title(['Trajectory of Myosin Head']);
% legend


%Taking final (and 1/3*t_end_true and 2/3*t_end_true too?) trajectory state of all myosin and plot as Trajectory State vs. myosin number
%Save mean and std
st_traj_1stThird = st_cont(:, floor(tot_timesteps/3));
st_traj_2ndThird = st_cont(:, floor(tot_timesteps*(2/3)));
st_traj_final = st_cont(:, end);
m_traj = [1:m_nodes].';

st_traj_final_Mean = mean(st_traj_final);
st_traj_final_Std = std(st_traj_final);
% disp(st_traj_final_Mean)
% disp(st_traj_final_Std)
st_traj_data(sim_counter, 1:2) = [st_traj_final_Mean, st_traj_final_Std];

% figure(305)
% plot(m_traj, st_traj_1stThird, '-*');
% hold on
% plot(m_traj, st_traj_2ndThird, '-*');
% plot(m_traj, st_traj_final, '-*');
% xlabel('Myosin Number');
% ylabel('State Progression');
% title(['State Progression of ', num2str(m_nodes) ,' Myosin Heads (t = ', num2str(round(t_end_true, 2)), 's)']);
% legend('States at 1/3 End Time', 'States at 2/3 End Time', 'States at End Time');



end %if m_nodes <= 2 else (all other numbers of myosin nodes)
end %if create_traj_plots == true

end %end simulation loop


%% AVERAGE OUTPUTS OF SIMULATION

% fprintf('For testcase %s, prob_summed_max_exact = %.2f, and timesteps = %i \n', testcase, prob_sum_max_exact, tot_timesteps-1);
% fprintf('conc_ATP = %.2e, conc_ADP = %.2e \n', conc_ATP_vec(cf_ATP), conc_ADP_vec(cf_ADP));

avg_t_end_true = mean(t_end_true_store);
% fprintf('Average End Time = %f s for n = %i \n', avg_t_end_true, n_sim);

avg_duty_ratio = mean(duty_ratio_store(1, :));
%%{
fprintf('Average Duty Ratio = %f for n = %i \n', avg_duty_ratio, n_sim);
avg_DR_st1 = mean(DR_st1_store(1, :));
fprintf('Average DR_st1 = %f for n = %i \n', avg_DR_st1, n_sim);
avg_DR_st2 = mean(DR_st2_store(1, :));
fprintf('Average DR_st2 = %f for n = %i \n', avg_DR_st2, n_sim);
%}
%{
% avg_avg_res_times_st1 = mean(mean(avg_res_times_store(:,1,:)));
% avg_avg_res_times_st2 = mean(mean(avg_res_times_store(:,2,:)));
% avg_avg_res_times_st3 = mean(mean(avg_res_times_store(:,3,:)));
for i = 1:3
    fprintf('Average Residence Time in State %i = %f s for n = %i \n', i, mean(mean(avg_res_times_store(:,i,:))), n_sim);
end
%}
avg_t_cycle_avg = mean(mean(t_cycle_avg_store, 'omitnan'), 'omitnan'); % in seconds
avg_t_cycle_avg_NaN = mean(mean(t_cycle_avg_store, 'omitnan')); % in seconds
avg_t_cycle_avg_mult = mean(t_cycle_avg_store, 'omitnan'); 

% fprintf('Avg. Cycle Time = %f s for %i \n', avg_t_cycle_avg, n_sim);
avg_t_cycle_median = mean(mean(t_cycle_median_store));
% fprintf('Median Cycle Time = %f s for %i \n', avg_t_cycle_median, n_sim);

avg_avg_F_output = mean(avg_F_output_store(1,:));
avg_avg_F_output_std = std(avg_F_output_store(1,:));
avg_avg_F_output_mline = mean(avg_F_output_mline_store(1,:));

%%{
fprintf('Average Force = %f pN for n = %i \n', avg_avg_F_output, n_sim);
avg_F_var = mean(F_var_store(1,:));
avg_F_var_Norm2Peak = mean(F_var_Norm2Peak_store(1,:));
avg_F_var_Norm2Avg = mean(F_var_Norm2Avg_store(1,:));
avg_F_std = mean(F_std_store(1,:));
fprintf('Average Force Variance = %f pN^2 for n = %i \n', avg_F_var, n_sim);
% fprintf('Average Force Variance (Norm2Peak) = %f pN^2 for n = %i \n', avg_F_var_Norm2Peak, n_sim);
% fprintf('Average Force Variance (Norm2Avg) = %f pN^2 for n = %i \n', avg_F_var_Norm2Avg, n_sim);
fprintf('Average Force Std. Dev. = %f pN for n = %i \n', avg_F_std, n_sim);
avg_F_per_cycle = mean(F_per_cycle_store(1, :));
fprintf('Average Force per Cycle = %f pN for n = %i \n', avg_F_per_cycle, n_sim); 
%}

avg_ATP_per_time = mean(ATP_per_time_store(1, :));
%%{
avg_RMSE_ATP = mean(RMSE_ATP_store(1,:));
fprintf('Average ATP/s = %f ATP/s for n = %i \n', avg_ATP_per_time, n_sim);
fprintf('Average RMSE for ATP = %f ATP for n = %i \n', avg_RMSE_ATP, n_sim);
if avg_t_end_true >= 2 + t(t_Ca) && t(t_Ca) < 2
    avg_ATP_per_time_2s = mean(ATP_per_time_2s_store(1, :));
    fprintf('Average ATP/s (first 2s) = %f molecules/s for n = %i \n', avg_ATP_per_time_2s, n_sim);
end
avg_ATP_total = mean(ATP_total_store(1, :));
avg_ATP_1s_total = mean(ATP_1s_total_store(1, :));
fprintf('Average Total ATP Consumed = %2f molecules (t = %2f s) for n = %i \n', avg_ATP_total, t_end_true, n_sim);
fprintf('Average Total ATP Consumed in 1 s = %2f molecules (t = 1 s) for n = %i \n', avg_ATP_1s_total, n_sim);
Natp = avg_avg_F_output/max(F_output)*avg_t_end_true/(avg_duty_ratio*avg_t_end_true/sum(N_states(:,a_nodes+2)==3));
avg_Foutput_test = max(F_output)*(avg_duty_ratio*avg_t_end_true/sum(N_states(:,a_nodes+2)==3))*sum(N_states(:,a_nodes+2)==3)/avg_t_end_true;
%}

% avg_avg_work_per_ATP = mean(avg_work_per_ATP_store(1, :));
% fprintf('Average Work/ATP = %s J/ATP for n = %i \n', avg_avg_work_per_ATP, n_sim);
% avg_total_work = mean(total_work_store(1, :));
% fprintf('Average Total Work = %s for n = %i \n', avg_total_work, n_sim);
% avg_k_eff = mean(k_eff_overall_store(1, :));
% fprintf('Average K_eff = %s pN for n = %i \n', avg_k_eff, n_sim);
% % if m_nodes == 1
% %     avg_k_eff_23 = mean(k_eff_23_overall_store(1, :));
% %     fprintf('Average K_eff_23 = %s pN for n = %i \n', avg_k_eff_23, n_sim);
% % end
% fprintf('=============================================================== \n');

% POTENTIAL ENERGY - characteristic time of fluctuations
avg_t_char_fluc = mean(t_char_fluc_store);

% Find unique values of dt throughout last simulation (sim 3 usually)
[dt_store_unique_data, ia, ic] = unique(dt_store); %want the unique values of dt_store
dt_counts = accumarray(ic, 1);
dt_store_unique = [dt_store_unique_data.', dt_counts];
for j = 1:length(dt_store_unique_data)
%    dt_store_unique(j, 3:3+m_nodes-1) = N_states(find(dt_store(t_Ca:tot_timesteps-1) == dt_store_unique_data(j), 1, 'last')+(t_Ca-1), a_nodes+2:tot_nodes-1);
   dt_store_unique(j, 3:3+a_nodes+m_nodes-1) = N_states(find(dt_store(t_Ca:tot_timesteps-1) == dt_store_unique_data(j), 1, 'last')+(t_Ca-1), 2:tot_nodes-1);
end

% Find unique values of cycle times throughout last simulation (sim 3 usually)
[t_cycle_unique_data, ia, ic] = unique(round(t_cycle_times*1e3, 1)); %want unique values of t_cycle_times
% [t_cycle_unique_data, ia, ic] = unique(round(t_cycle_times*1e3, 3)); %want unique values of t_cycle_times
t_cycle_counts = accumarray(ic, 1);
t_cycle_unique = [t_cycle_unique_data.', t_cycle_counts];

% Find and store unique values of F_output (pN) throughout last simulation (sim 3 usually)
[F_op_unique_data, ia, ic] = unique(F_output);
F_op_counts = accumarray(ic, 1);
F_op_linked_Epot = E_potential_ext(ia)*1e21; %in pN*nm
% F_op_unique = [F_op_unique_data.', F_op_linked_Epot, F_op_counts]; %Columns: F_op, Epot, iterations, actin-myosin configurations]
% for j = 1:length(F_op_unique_data)
%    F_op_unique(j, 4:4+a_nodes+m_nodes-1) = N_states(find(F_output(t_Ca:tot_timesteps-1) == F_op_unique_data(j), 1, 'last')+(t_Ca-1), (2:tot_nodes-1));
% end
%Commented out above 12/2/2021 when testing test cases with high force and large number of myosin PICKUP 

% Plateau ATP/s (ATP consumption rate)
plat_ATPConsAvgSims_ATPADP = mean(plat_ATPConsPerSim(1, :));
plat_ATPConsStdSims_ATPADP = std(plat_ATPConsPerSim(1, :));


% Save values for correlation function
if save_data_for_corr_func == true
       corr_func_vars = ['CorrFuncVars_testcase=', num2str(testcase), '_', ...
                            'a_nodes=', num2str(a_nodes), '_', ...
                            'm_nodes=', num2str(m_nodes), '_', ...
                            'conc_ADP(', num2str(conc_ADP_vec(cf_ADP)), ')_', ...
                            'conc_ATP(', num2str(conc_ATP_vec(cf_ATP)), ')_', ...
                            'a0=', num2str(a0), '_', ...
                            'm0=', num2str(m0), '_', ...
                            'tot_timesteps=', num2str(tot_timesteps), '_', ...
                            't_end_true=', num2str(t_end_true), '.mat']; 
       save(corr_func_vars, 'F_output_corr', 'dt_store_corr', 't_corr', 't_end_true_store', 'avg_F_output_store', 'n_sim');
end


%% Excel outputs, change as needed
% excel_op_K = [conc_ATP_vec(cf_ATP)*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 3), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 3), K23_store(find(K23_store, 1, 'first')), k31_store(find(k31_store, 1, 'first'))];
% % excel_op = [conc_ATP*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 3), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 3), round(avg_t_cycle_avg*1e3, 2), round(avg_t_cycle_median*1e3, 2)];
% % excel_op_K = [conc_ADP*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 3), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 3), K23_store(find(K23_store, 1, 'first')), k31_store(find(k31_store, 1, 'first'))];
% % excel_op = [conc_ADP*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 3), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 3), round(avg_t_cycle_avg*1e3, 2), round(avg_t_cycle_median*1e3, 2)];
% excel_op = [conc_ATP_vec(cf_ATP)*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 2, 'significant'), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 2, 'significant'), round(avg_t_cycle_avg*1e3, 2), round(avg_t_cycle_median*1e3, 2)];
% % excel_op_comb = [conc_ATP_vec(cf_ATP)*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 2, 'significant'), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 2, 'significant'), round(avg_t_cycle_avg*1e3, 2), round(avg_t_cycle_median*1e3, 2), K23_store(find(K23_store, 1, 'first')), k31_store(find(k31_store, 1, 'first'))];
% excel_op_comb = [conc_ATP_vec(cf_ATP)*1e3, conc_ADP_vec(cf_ADP)*1e3, round(avg_t_end_true, 2), round(avg_duty_ratio, 2, 'significant'), round(avg_ATP_per_time, 0), round(avg_avg_F_output, 2, 'significant'), round(avg_t_cycle_avg*1e3, 2), K23_store(find(K23_store, 1, 'first')), k31_store(find(k31_store, 1, 'first'))];
% excel_op_unrounded = [conc_ATP_vec(cf_ATP)*1e3, avg_t_end_true, avg_duty_ratio, avg_ATP_per_time, avg_avg_F_output, avg_t_cycle_avg*1e3, avg_t_cycle_median*1e3];
% 
% 
% 
% Store outputs of [ATP] vs. [ADP] vs. cycle time/other params
%store avg_cycle_time_avg
TvD_store(cf_ATP, cf_ADP, 1) = round(avg_t_cycle_avg*1e3, 2); 
% %store avg_avg_F_output
TvD_store(cf_ATP, cf_ADP, 2) = avg_avg_F_output; %round(avg_avg_F_output, 2, 'significant'); 
% %store K23
TvD_store(cf_ATP, cf_ADP, 3) = K23_store(find(K23_store, 1, 'first')); 
% %store k31
TvD_store(cf_ATP, cf_ADP, 4) = k31_store(find(k31_store, 1, 'first'));
% %store duty ratio
TvD_store(cf_ATP, cf_ADP, 5) = round(avg_duty_ratio, 2, 'significant');
% %store ATP/s
TvD_store(cf_ATP, cf_ADP, 6) = round(avg_ATP_per_time, 0);
% %store Residence Time in State 3
TvD_store(cf_ATP, cf_ADP, 7) = mean(mean(avg_res_times_store(:,3,:), 'omitnan'), 'omitnan');
% %Store plateau ATP/s
TvD_store(cf_ATP, cf_ADP, 8) = plat_ATPConsAvgSims_ATPADP;
%store avg_cycle_time_avg including NaN (no cycle)
TvD_store(cf_ATP, cf_ADP, 9) = round(avg_t_cycle_avg_NaN*1e3, 2); 

%store excel_op_comb going through conc values of [ATP]_1toN @ [ADP]_1 and then conc values of [ATP]_1toN @ [ADP]_2 etc
% excel_op_store(excel_op_counter, :) = excel_op_comb;

% FOR MULTIPLE MYOSIN:
% Store outputs of [ATP] vs. [ADP] vs. cycle time/other params 
%store avg_cycle_time_avg_mult (for when there are multiple myosin)
% for m = 1:m_nodes
%     TvD_mult_store(cf_ATP, cf_ADP, m) = round(avg_t_cycle_avg_mult(m)*1e3, 2);
% end

end %end ATP concentration loop
end %end ADP concentration loop


%Update Total Time Value
extLoopTotTime = extLoopTotTime + toc(timerVal_sim);
end %end External Loop loop

%Displaying the total time of the total simulations (inside and external loop)
if display_code_runtime == true
    fprintf('TOTAL of %i Simulations completed at total code runtime = %f s \n', totalSimCounter, extLoopTotTime);
end

%% Trajectory Plot
%%{
if create_StTraj_plot == true

% Trajectory Plot Data
% Create two vectors that track the state trajectory of the single myosin head over time

% Vector for time (starts at t(t_Ca+1) and then repeats from there i.e. [t1, t2, t2, t3, t3, t4, t4, ..., t_end, t_end])
t_traj = [t(t_Ca+2:end); t(t_Ca+2:end)];
t_traj = t_traj(:);
t_traj = [t(t_Ca+1); t_traj];

% Vector for trajetory of states
xb_trans_store_traj = xb_trans_store(t_Ca+1:end, 1).';
if m_nodes ~=1
   xb_trans_store_traj = xb_trans_store(t_Ca+1:end, :).'; 
end
xb_trans_store_traj(xb_trans_store_traj == -2) = 1; %replace all -2 (3 -> 1) transitions with 1
xb_trans_store_traj(xb_trans_store_traj == 2) = -1; %replace all 2 (1 -> 3) transitions with -1

% Create vector of continuous state of myosin i.e. continue counting upwards instead of cycling 3 -> 1 at end of cycle
for m = 1:m_nodes
    st_curr = 1; %current state that counts up i.e. the second state 1 is 4 and the second state 2 is 5 and so on
    % st_cont(1:t_Ca) = 1;
    st_cont(m, 1) = 1; %stores the continuous value of the state of the myosin head i.e. 1, 2, 3, 4, 5, 4, 5, 6, etc
    for i = 1:length(xb_trans_store_traj)-1
        st_curr = st_curr + xb_trans_store_traj(m, i);
    %     st_cont(t_Ca+i) = st_curr;
        st_cont(m, i+1) = st_curr;
    end
end

if m_nodes <=2
if m_nodes == 2
   st_cont3D = st_cont;
   st_cont = sum(st_cont); %sum of the continuous states each myosin is in at each time point (sums each column and produces row vector)
end
% st_traj = [N_states(1:end-1, a_nodes+2).'; N_states(2:end, a_nodes+2).'];
% traj_data = [xb_trans_store(t_Ca+1:end,1), xb_trans_store_traj.', st_cont.'];
% traj_data = [xb_trans_store(t_Ca+1:end,1), xb_trans_store_traj.', st_cont.', N_states(t_Ca+1:end-1, a_nodes+2)];
% Vector for continuous trajectory of states of myosin (starts and repeats state 1 and then repeats from there ending with an additional repeat of final state i.e. [st1, st1, st2, st2, st3, st3,..., st_end, st_end, st_end])
st_traj = [st_cont; st_cont];
st_traj = [st_traj(:); st_cont(end)];
traj_plot = [t_traj, st_traj];

%For 3D trajectory plot
if m_nodes == 2
    st_traj3D_y = [st_cont3D(1,:); st_cont3D(1,:)];
    st_traj3D_y = [st_traj3D_y(:); st_traj3D_y(end)];
    st_traj3D_z = [st_cont3D(2,:); st_cont3D(2,:)];
    st_traj3D_z = [st_traj3D_z(:); st_traj3D_z(end)];
    traj_plot3d = [t_traj, st_traj3D_y, st_traj3D_z];
end

% CALCULATE LINEAR REGRESSION
% y-intercept not fixed
[coeff_traj, S] = polyfit(traj_plot(:,1), traj_plot(:,2), 1); %calculates fit line coefficients
% [traj_lr, delta] = polyval([coeff_traj(1), coeff_traj(2)], traj_plot(:,1), S); %traj_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
t_traj_lr = t(t_Ca+2:end);
[traj_lr, delta] = polyval([coeff_traj(1), coeff_traj(2)], t_traj_lr, S); %traj_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME) - model evaluated at nonrepeated values of t

%CALCULATE RMSE
% RMSE_traj = sqrt(sum((traj_lr - traj_plot(:,2)).^2, 'omitnan')/length(traj_lr)); %pickup [9/27/2021] does this need to be weighted? .*(dt_store/t_end_true)-- %when traj_lr is composed of repeated values for state progression (y axis)
RMSE_traj = sqrt(sum((traj_lr - st_cont).^2, 'omitnan')/length(traj_lr)); %%when traj_lr is composed of non-repeated values for state progression (y axis)) 

% if fix_trajlr_int == true
    % y-intercept fixed at origin (0,1)
%     traj_lr_mdl = fitlm(traj_plot(:,1), traj_plot(:,2), 'y~x1-1');
%     traj_lr = traj_plot(:,1)*(traj_lr_mdl.Coefficients.Estimate);
% end
traj_lr_text = sprintf('y = %.3fx + %.3f (black) \n RMSE_{raw} = %.2f \n RMSE_{cyc} = %.1f cycles', coeff_traj(1), coeff_traj(2), RMSE_traj, RMSE_traj/3); %Convert the equation into text - intercept = (0,0)            

%Plot State Trajectory
figure(300)
plot(traj_plot(:,1), traj_plot(:,2));
hold on
% plot(traj_plot(:,1), traj_lr, '--k', 'LineWidth', 0.5);
plot(t(t_Ca+2:end), traj_lr, '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
% set(gca,'YTickLabel',{'1','2','3'});
xlabel('time (s)');
ylabel('State Progression');
% set(gca, 'ytick', [1:3:(traj_plot(end, 2) + (3 - mod(traj_plot(end, 2), 3)) )]);
% set(gca, 'ytick', linspace(0, (traj_plot(end, 2) + (9 - mod(traj_plot(end, 2), 9))), 10));
title(['Trajectory of Myosin Head']);
% text(0.7*t_end_true, 0.3*traj_plot(end,2), traj_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot
text(0.6*t_end_true, 0.7*median(traj_plot(:,2)), traj_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot

%Plot State Trajectory inset
figure(301)
traj_span = 30; %make sure even number
% traj_start = find(N_states(floor((tot_timesteps-1)/2):end, a_nodes+2) == 1, 1, 'first');
% plot(traj_plot(traj_start+floor((tot_timesteps-1)/2)*2+1:traj_start+floor((tot_timesteps-1)/2)*2+1+40,1), traj_plot(traj_start+floor((tot_timesteps-1)/2)*2+1:traj_start+floor((tot_timesteps-1)/2)*2+1+40,2));
plot(traj_plot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+traj_span,1), traj_plot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+traj_span,2));
hold on
% plot(traj_plot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+30,1), traj_lr(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+30), '--k', 'LineWidth', 0.5);
% plot(t((((tot_timesteps-1)/2)+t_Ca+2):(((tot_timesteps-1)/2)+traj_span)+t_Ca+2), traj_lr(((tot_timesteps-1)/2):((tot_timesteps-1)/2+traj_span)), '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
plot(t_traj_lr((ceil(length(t_traj_lr)/2)):(ceil(length(t_traj_lr)/2)+traj_span/2)), traj_lr(((tot_timesteps-1)/2):((tot_timesteps-1)/2+traj_span/2)), '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
% set(gca,'YTickLabel',{'1','2','3'});
ylim([floor(traj_plot(((tot_timesteps-1)/2)*2, 2))-2, floor(traj_plot(((tot_timesteps-1)/2)*2, 2)) + 16]);
xlabel('time (s)');
ylabel('State Progression');
title('Trajectory of Myosin Head');

if m_nodes == 2
    % 3D trajectory plot regression line (from https://www.mathworks.com/matlabcentral/answers/424591-3d-best-fit-line)
    traj_plot3d_trans = traj_plot3d.'; %3x12000 matrix
    traj_plot3d_mean = mean(traj_plot3d_trans, 2); %3x1 vector of means of t, y, and z
    tp3d_A = traj_plot3d_trans - traj_plot3d_mean;
    [U,S,~] = svd(tp3d_A);
    d_tp3d = U(:,1);
    t_tp3d = d_tp3d'*tp3d_A;
    traj_plot3d_trans_line = traj_plot3d_mean + [min(t_tp3d), max(t_tp3d)].*d_tp3d; %contains the two 3D points for line of best fit
    %Parametric equation of line: tp3D_trans_line = P*tp3D_trans_line(:,1) + (1-P)*tp3D_trans_line(:,2) where P is a real parameter?
%     eqns = [x(P) == traj_plot3d_trans_line(1,1) + (traj_plot3d_trans_line(1,2)-traj_plot3d_trans_line(1,1))*P; ...
%            [y(P) == traj_plot3d_trans_line(2,1) + (traj_plot3d_trans_line(2,2)-traj_plot3d_trans_line(2,1))*P; ...
%            [z(P) == traj_plot3d_trans_line(3,1) + (traj_plot3d_trans_line(3,2)-traj_plot3d_trans_line(3,1))*P];
%     r(P) = traj_plot3d_trans_line(:,1) + P*(traj_plot3d_trans_line(:,2)-traj_plot3d_trans_line(:,1));
    traj_unitvec = (traj_plot3d_trans_line(:,2)-traj_plot3d_trans_line(:,1))/norm(traj_plot3d_trans_line(:,2)-traj_plot3d_trans_line(:,1));
    traj3d_lr_text = sprintf('r(P) = <%.2f, %.2f, %.2f> + P*<%.2e, %.2f, %.2f>', traj_plot3d_trans_line(1,1), traj_plot3d_trans_line(2,1), traj_plot3d_trans_line(3,1),...
                                                                                 traj_unitvec(1), traj_unitvec(2), traj_unitvec(3));             

    
    figure(303)
    plot3(traj_plot3d(:,1), traj_plot3d(:,2), traj_plot3d(:,3));
    hold on
    plot3(traj_plot3d_trans_line(1,:), traj_plot3d_trans_line(2,:), traj_plot3d_trans_line(3,:), 'r');
    grid on
    xlabel('time (s)');
    ylabel('State Progression (m1)');
    zlabel('State Progression (m2)');
    title('Trajectory of Myosin Heads');
    text(0.3*t_end_true, 1.6*median(traj_plot3d(:,2)), 1.25*median(traj_plot3d(:,3)), traj3d_lr_text, 'FontSize', 9, 'Color', 'k'); %Insert the regression equation into the plot
end

else %- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    
%Remaining cases where m_nodes is not <= 2
%Want to create plot that tracks each individual myosin's path through all the states as different trajectory traces
% Vector for continuous trajectory of states of myosin (starts and repeats state 1 and then repeats from there ending with an additional repeat of final state i.e. [st1, st1, st2, st2, st3, st3,..., st_end, st_end, st_end])
for m = 1:m_nodes
    st_traj_temp = [st_cont(m,:); st_cont(m,:)];
    st_traj_temp = [st_traj_temp(:); st_cont(m, end)];
    st_traj(m, :) = st_traj_temp;
end

%Plot State Trajectory
turbo3CM = turbo(m_nodes);

figure(304)
for m = 1:m_nodes
plot(t_traj, st_traj(m, :), "Linewidth", 1, 'Color', turbo3CM(m, :), 'DisplayName', ['myosin ', num2str(m)]);
hold on
end
xlabel('time (s)');
ylabel('State Progression');
% set(gca, 'ytick', [1:3:(traj_plot(end, 2) + (3 - mod(traj_plot(end, 2), 3)) )]);
% set(gca, 'ytick', linspace(0, (traj_plot(end, 2) + (9 - mod(traj_plot(end, 2), 9))), 10));
title(['Trajectory of Myosin Head']);
legend


%Taking final (and 1/3*t_end_true and 2/3*t_end_true too?) trajectory state of all myosin and plot as Trajectory State vs. myosin number
%Save mean and std
st_traj_1stThird = st_cont(:, floor(tot_timesteps/3));
st_traj_2ndThird = st_cont(:, floor(tot_timesteps*(2/3)));
st_traj_final = st_cont(:, end);
m_traj = [1:m_nodes].';

st_traj_final_Mean = mean(st_traj_final);
st_traj_final_Std = std(st_traj_final);
% disp(st_traj_final_Mean)
% disp(st_traj_final_Std)
st_traj_data = [st_traj_final_Mean, st_traj_final_Std];

figure(305)
plot(m_traj, st_traj_1stThird, '-*');
hold on
plot(m_traj, st_traj_2ndThird, '-*');
plot(m_traj, st_traj_final, '-*');
xlabel('Myosin Number');
ylabel('State Progression');
title(['State Progression of ', num2str(m_nodes) ,' Myosin Heads (t = ', num2str(round(t_end_true, 2)), 's)']);
legend('States at 1/3 End Time', 'States at 2/3 End Time', 'States at End Time');



end %if m_nodes <= 2 else (all other numbers of myosin nodes)
end %if create_traj_plots == true
%}

%% Potential Energy Plot
%%{
if create_Epot_plot == true
% CALCULATE LINEAR REGRESSION
% y-intercept not fixed
[coeff_Epot, S] = polyfit(t.', E_potential_ext*1e12*1e9, 1); %calculates fit line coefficients
[Epot_lr, delta] = polyval([coeff_Epot(1), coeff_Epot(2)], t, S); %Epot_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME) - model evaluated at nonrepeated values of t

%CALCULATE RMSE
RMSE_Epot = sqrt(sum((Epot_lr - (E_potential_ext*1e12*1e9).').^2, 'omitnan')/length(Epot_lr)); %%when traj_lr is composed of non-repeated values for state progression (y axis))           

% Generate time and Epot vectors for "trajectory" plot of Epot i.e. looks like step function
t_Epot = [t(t_Ca+2:end); t(t_Ca+2:end)]; 
t_Epot = t_Epot(:);
t_Epot = [t(t_Ca+1); t_Epot];
Epot_traj = [E_potential_ext(t_Ca+1:end).'; E_potential_ext(t_Ca+1:end).'];
Epot_traj = Epot_traj(:);
Epot_traj(end) = [];
Epot_traj_data = [t_Epot, Epot_traj];



% Text for Epot linear regression line
Epot_lr_text = sprintf('y = %.2ex + %.2e (black) \n RMSE = %.2e pn*nm \n T_{char} = %.2e s', coeff_Epot(1), coeff_Epot(2), RMSE_Epot, avg_t_char_fluc); %Convert the equation into text 

% Potential Energy
figure(400)
plot(t_Epot, Epot_traj*1e12*1e9); %convert N*m to pN*nm
hold on
xlabel('Time (s)');
ylabel('Elastic Potential Energy (pN*nm)'); %Note: J and N*m are the same thing
title('Elastic Potential Energy of External Spring (pN*nm) vs. Time (s)');
plot(t, Epot_lr, '--k', 'LineWidth', 0.5);
text(0.6*t_end_true, 0.7*max(E_potential_ext*1e12*1e9), Epot_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot

% Potential Energy ("cumulative" v. 1)
% figure(401)
% plot(t_Epot, cumsum(Epot_traj*1e12*1e9)); %convert N*m to pN*nm
% hold on
% xlabel('Time (s)');
% ylabel('Elastic Potential Energy (pN*nm)'); %Note: J and N*m are the same thing
% title('Elastic Potential Energy of External Spring (pN*nm) vs. Time (s)');
% plot(t, Epot_lr, '--k', 'LineWidth', 0.5);
% % text(0.6*t_end_true, 0.7*max(cumsum(E_potential_ext*1e12*1e9)), Epot_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot
 
%Plot Potential Energy inset
figure(402)
Epot_traj_span = 30; %make sure even number
plot(t_Epot(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+Epot_traj_span), Epot_traj(((tot_timesteps-1)/2)*2:((tot_timesteps-1)/2)*2+Epot_traj_span)*1e12*1e9);
hold on
plot(t((ceil(length(Epot_lr)/2)):(ceil(length(Epot_lr)/2)+Epot_traj_span/2)), Epot_lr(((tot_timesteps-1)/2):((tot_timesteps-1)/2+Epot_traj_span/2)), '--k', 'LineWidth', 0.5); %when traj_lr is composed of non-repeated values for state progression (y axis)
ylim([floor(Epot_traj(((tot_timesteps-1)/2)*2))-2, floor(Epot_traj(((tot_timesteps-1)/2)*2)) + 16]);
% ylim([0, max(Epot_traj*1e21)+1]);
xlabel('time (s)');
ylabel('Potential Energy (pn*nm)');
title('Elastic Potential Energy of External Spring (pN*nm) vs. Time (s)');
text(t((tot_timesteps-1)/2), 0.5*max(E_potential_ext((tot_timesteps-1)/2:(tot_timesteps-1)/2+Epot_traj_span))*1e21, Epot_lr_text, 'FontSize', 12, 'Color', 'k'); %Insert the regression equation into the plot


% Calculate Cumulative Potential Energy as sum of potential energy drops between subsequent states
Epot_diff =  diff(E_potential_ext(t_Ca+1:end)*1e12*1e9); %Convert N*m to pn*nm
% E_pot_diff = E_pot_diff(E_pot_diff > 0); %Remove all negative potential energy differences
Epot_diff(Epot_diff < 0) = 0; %Make all negative potential energy differences equal to zero
Epot_diff_cum = cumsum(Epot_diff);

% Create Vectors to plot Cumulative Potential Energy
Epot_diff_cum_traj = [Epot_diff_cum.'; Epot_diff_cum.'];
Epot_diff_cum_traj = [Epot_diff_cum_traj(:); Epot_diff_cum(end)];

%Check that energy from ATP hydrolysis put into the system is greater than the elastic potential energy experienced by the system
%Note: Values below are only for final simulation
Epot_IntExtSprings_data(:,3) = Epot_IntExtSprings_data(:, 1)+Epot_IntExtSprings_data(:, 2);
Epot_IntExtSprings_diff = diff(Epot_IntExtSprings_data(:,3))*1e-21; %convert from pn*nm to J (N*m)
Epot_IntExtSprings_diff(Epot_IntExtSprings_diff<0) = 0;
Epot_efficiency = sum(Epot_IntExtSprings_diff)/(ATPase_tracker_plot_eaSim_store(totalSimCounter, end)*(kB*T*log((conc_ATP)/((conc_P)*(conc_ADP))) + dG_hyd_st));
Epot_efficiency2 = sum(Epot_IntExtSprings_diff)/(ATPase_tracker_plot_eaSim_store(totalSimCounter, end)*8.3e-20); %ATP free energy from literature

%Cumulative Potential Energy Graph
figure(403)
plot(t_Epot, Epot_diff_cum_traj); %convert N*m to pN*nm
hold on
xlim([0, t_end_true+0.5]);
xlabel('Time (s)');
ylabel('Elastic Potential Energy (pN*nm)'); %Note: J and N*m are the same thing
title('Cumulative Elastic Potential Energy (sum of spikes) of External Spring (pN*nm) vs. Time (s)');

end %if create_Epot_plot == true

%% Force for each xb Plot

if create_Fxb_plot == true
    % Plot Force of each xb and sum of their forces
    figure(500)
    plot(t, F_xb_store(:,1:m_nodes), '.'); %multiple lines for each xb
    hold on
    xlabel('Time (s)');
    ylabel('Force borne by each xb (pN)');
    title('Force of each xb (pN) vs. Time (s)');
    hold on
    plot(t, F_xb_store(:, m_nodes+2) , '-c', 'LineWidth', 0.5); %sum of forces borne by each xb
    
    % Plot Force of each xb inset
    figure(501)
    Fxb_span = 30; %make sure even number
    start_span_divisor = 5; %make sure tot_timesteps-1 is divisible by ssd
    ssd = start_span_divisor;
    Fxb_spanx = [((tot_timesteps-1)/ssd):((tot_timesteps-1)/ssd) + Fxb_span];
%     Fxb_spanx = [80255:80283];
    plot(t(Fxb_spanx), F_xb_store(Fxb_spanx, 1:m_nodes), '-o');
    hold on
%     ylim([floor(F_xb_store((tot_timesteps-1)/2))-2, floor(min(F_xb_store(((tot_timesteps-1)/2):((tot_timesteps-1)/2)+Fxb_span, 1:2), [], 'all')) + 16]);
    ylim([floor(min(F_xb_store(Fxb_spanx, 1:2), [], 'all'))-2, ceil(max(F_xb_store(Fxb_spanx, 1:2), [], 'all'))]);
    xlabel('time (s)');
    ylabel('Force borne by each xb (pN)');
    title('Force of each xb (pN) vs. Time (s)');
    hold on
    plot(t(Fxb_spanx), F_xb_store(Fxb_spanx, m_nodes+2) , '-oc', 'LineWidth', 0.5); %sum of forces borne by each xb
    plot(t(Fxb_spanx), F_output(Fxb_spanx) , '--*k', 'LineWidth', 0.5); %sum of forces borne by each xb
    
end

%if create_Fxb_plot == true

%}
%% 3D Plot of ATP/s or other outputs vs ADPPi and ATP when there is (our model) and is not (previous models) a fixed ratio of ATP/ADPPi
%{
    
% Create table to match ratios of log_ratio_ADPPioverATP_pairs with those in log_z_ADPPiATP
Rn = log_z_ADPPiATP;
fRn = NaN(size(log_z_ADPPiATP));

for ATP_i = 1:length(y_ADPPi)
    ADP_i = [length(x_ATP):-1:1];
    TvD_ATPperS(ATP_i, 1) = TvD_store(ATP_i, ADP_i(ATP_i), 8); %column vector of the output of interest (ATP/s) that align with the ratios of interest in log_ratio_ADPPioverATP_pairs    
end
fullLog_ATP_ADPPi_Ratio_DataTable = [fullLog_ATP_ADPPi_Ratio_DataTable, TvD_ATPperS];

%Create the vector of known (Rn, f(Rn)) pairs to be put into interpolation
Rn_vs_fRn_sampled = [log_ratio_ADPPioverATP_pairs, TvD_ATPperS];

%create two rounded off vectors of the sample ratios and all the ratios of log10(ATP/(ADPPi))
round_log_z_ADPPiATP = round(log_z_ADPPiATP, 2);
round_log_ratio_ADPPioverATP_pairs = round(log_ratio_ADPPioverATP_pairs, 2);

% [row, col, values] = find(round_log_z_ADPPiATP~=round_log_ratio_ADPPioverATP_pairs)
% Rn_interp = log_z_ADPPiATP(find(round(log_z_ADPPiATP, 2) ~= round(log_ratio_ADPPioverATP_pairs, 2))); %Find the Ratio values that were not in the diagonal of sample chosen ratios that will need interpolated output values

%Create storage matrix for inverse of the indices of ratios Rn that need to have f(Rn) interpolated for them
Rn_interp_ind_inv = zeros(size(log_z_ADPPiATP));

for i = 1:length(log_ratio_ADPPioverATP_pairs)
   log_ratio_curr = round_log_ratio_ADPPioverATP_pairs(i); %what is the current sampled ratio we are looking at
   Rn_interp_ind_curr = (round_log_z_ADPPiATP == log_ratio_curr); %want to find the ratios that do match the sampled ratios, then inverse the indexing matrix to find the ones we need to interpolate
   [ri, ci] = find(round_log_z_ADPPiATP == log_ratio_curr); %Get all row and column indices of the sampled ratio in the ratio Rn matrix
%    fRn(ri, ci) = TvD_ATPperS(i); %Fill in fRn in the same spots with the corresponding ATP/s value
   fRn_ind = sub2ind(size(fRn), ri, ci);
   fRn(fRn_ind) = TvD_ATPperS(i); %Fill in fRn in the same spots with the corresponding ATP/s value
   Rn_interp_ind_inv =  Rn_interp_ind_inv + Rn_interp_ind_curr; %update matrix
end

%Create storage matrix for indices of ratios Rn that need to have f(Rn) interpolated for them
Rn_interp_ind = ~Rn_interp_ind_inv;
Rn_interp = log_z_ADPPiATP(Rn_interp_ind); %the values of the ratios for which f(Rn) must be interpolated
[r_interp, c_interp] = find(Rn_interp_ind); %row, column (x,y) indices of Rn_interp values in their 16x16 matrix

Rn_interpTEMP = [Rn_interp, r_interp, c_interp];
Rn_interp_sorted = sortrows(Rn_interpTEMP);

%INTERPOLATE the values of f(Rn) for each of the non-originally-sampled ratios
fRn_interp = interp1(Rn_vs_fRn_sampled(:,1), Rn_vs_fRn_sampled(:,2), Rn_interp_sorted(:,1)); 
% fRn_interp = interp1(Rn_vs_fRn_sampled(:,1), Rn_vs_fRn_sampled(:,2), sort(Rn_interp)); 

%Plug in those values into the fRn matrix
for i = 1:length(fRn_interp)
    fRn_ind = sub2ind(size(fRn), Rn_interp_sorted(i, 2), Rn_interp_sorted(i, 3));
    fRn(fRn_ind) = fRn_interp(i); %Plug in the interpolated values into the f(Rn) matrix using their 16x16 indices previously saved
end

%Plotting
    
    save(TvDsavefilename)
    TvD_x_plot = log10(conc_ATP_vec);
    TvD_y_plot = log10(conc_ADPPi_vec);
    x_range = [1:conc_i_T_end];
    y_range = [1:conc_i_D_end];
%     x_range = [1:22];
%     y_range = [1:24];
    TvD_x = TvD_x_plot(x_range);
    TvD_y = TvD_y_plot(y_range);
%     TvD_x = TvD_x_plot;
%     TvD_y = TvD_y_plot;
    TvD_z = TvD_store(:,:,1); %Cycle times in (:,:,1), Force output in (:,:,2), K23 in (:,:,3), k31 in (:,:,4)
%     TvD_z = TvD_z(~isnan(TvD_z));
%     X = repmat(TvD_x.', size(TvD_z, 2), size(TvD_y, 2)); 
%     X = reshape(X, [], 1); %123/123/123/123/123/123/123/123 repeats to (number of values in c)*(number of values in b)
%     Y = repmat(TvD_y, size(TvD_x, 2), size(TvD_z, 2)); 
%     Y = reshape(Y, [], 1); %222444/222444/222444/222444 repeats to (number of values in c)
%     Z = repmat(TvD_z, size(TvD_x, 2)*size(TvD_y, 2), 1); 
%     Z = reshape(Z, [], 1); %000000/111111/222222/333333
%     TvD_z = TvD_store(:,:,8);
    [Y, X] = meshgrid(TvD_y, TvD_x); %TvD_y is ADPPi and TvD_x is ATP
    Z = TvD_z;
    
    % Plot plateau ATP/s
    figure(206)
    Z_2_platATPs = TvD_store(x_range,y_range,8); %reshape(excel_op_store(:,5), conc_i_end, conc_i_end);
    s = surf(X, Y, Z_2_platATPs, 'FaceColor', 'interp'); 
    hold on
    s.EdgeColor = 'none';
    xlabel('log([ATP]) M');
    ylabel('log([ADP*Pi]) M');
%     xlim([-10, 10]);
%     ylim([-12, 4]);
    zlabel('ATP/s');
    cb = colorbar;
    cb.Label.String = 'plateau ATP/s';
%     caxis([0, 2]);
%     caxis([20, max(TvD_store(x_range, y_range, 6), [], 'all')]);
    title(['[ATP] vs. [ADP] vs. ATP/s']);
    
%     figure(1)
%     plot(log10(conc_ADPPi_vec), log10(conc_ADP_vec));
    
%     % Plot plateau ATP/s with fixed ratios
    figure(207)
    Z_2_platATPs = fRn; %reshape(excel_op_store(:,5), conc_i_end, conc_i_end);
    s = surf(X, Y, Z_2_platATPs, 'FaceColor', 'interp'); 
    hold on
    s.EdgeColor = 'none';
    xlabel('log([ATP]) M');
    ylabel('log([ADP*Pi]) M');
    zlabel('ATP/s');
    cb = colorbar;
    cb.Label.String = 'plateau ATP/s';
%     caxis([0, 350]);
%     caxis([20, max(TvD_store(x_range, y_range, 6), [], 'all')]);
    title(['[ATP] vs. [ADP] vs. ATP/s with fixed ratios']);
    
    [Y, X] = meshgrid(log10(conc_ADP_vec), TvD_x); %Change from ADPPi to just ADP
    
    figure(208)
    Z_2_platATPs = TvD_store(x_range,y_range,8); %reshape(excel_op_store(:,5), conc_i_end, conc_i_end);
    s = surf(X, Y, Z_2_platATPs, 'FaceColor', 'interp'); 
    hold on
    s.EdgeColor = 'none';
    xlabel('log([ATP]) M');
    ylabel('log([ADP]) M');
    xlim([-12, 4]);
    ylim([-6, 10]);
    zlabel('ATP/s');
    cb = colorbar;
    cb.Label.String = 'plateau ATP/s';
%     caxis([20, max(TvD_store(x_range, y_range, 6), [], 'all')]);
    title(['[ATP] vs. [ADP] vs. ATP/s']);
    
    
    
    
%     % Plot Cycle Times
%     figure(200)
% %     nexttile
% %     scatter3(X, Y, Z, 15, 'filled');
%     surf(X, Y, Z, 'FaceColor', 'interp');
% %     surf(X, Y, TvD_store(x_range,y_range,1), 'FaceColor', 'interp');
%     hold on
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('Cycle Time (ms)');
%     %output
%     cb = colorbar;
%     caxis([0, 100]);
%     cb.Label.String = 'Cycle Time (ms)';
%     title(['[ATP] vs. [ADP*Pi] vs. Cycle Time (ms)']);
%     
%     % Plot Duty Ratio
%     figure(201)
% %     Z_2_DR = TvD_store(:,:,5); %reshape(excel_op_store(:,4), conc_i_end, conc_i_end);
%     Z_2_DR = TvD_store(x_range,y_range,5); %Duty Ratio ranges
%     surf(X, Y, Z_2_DR, 'FaceColor', 'interp');  %scatter3(log10(excel_op_store(:, 1)), log10(excel_op_store(:, 2)), excel_op_store(:, 4));
%     hold on
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('Duty Ratio');
%     cb = colorbar;
%     caxis([0,1]);
%     title(['[ATP] vs. [ADP] vs. Duty Ratio']);
%     
%     % Plot ATP/s
%     figure(202)
%     Z_2_ATPs = TvD_store(x_range,y_range,6); %reshape(excel_op_store(:,5), conc_i_end, conc_i_end);
%     surf(X, Y, Z_2_ATPs, 'FaceColor', 'interp'); 
%     hold on
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('ATP/s');
%     cb = colorbar;
% %     caxis([20, max(TvD_store(x_range, y_range, 6), [], 'all')]);
%     title(['[ATP] vs. [ADP] vs. ATP/s']);
%     
%     % Plot Avg. Force
%     figure(203)
%     Z_2_AvgF = TvD_store(:,:,2); %reshape(excel_op_store(:,6), conc_i_end, conc_i_end);
%     surf(X, Y, Z_2_AvgF, 'FaceColor', 'interp');  
%     hold on
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('Avg. Force');
%     cb = colorbar;
%     title(['[ATP] vs. [ADP] vs. Avg. Force']);
%     
%     % Plot prob 3->1 and prob 3->2
%     figure(204)
%     Z_k31 = TvD_store(:,:,4); %reshape(excel_op_store(:,9), conc_i_end, conc_i_end);
%     Z_K23 = TvD_store(:,:,3); %reshape(excel_op_store(:,8), conc_i_end, conc_i_end);
%     Z_k32 = 300./Z_K23;
%     Z_2_k31 = Z_k31./(Z_k31+Z_k32)*0.9;
%     Z_2_k32 = Z_k32./(Z_k31+Z_k32)*0.9;
%     colors_31 = zeros(conc_i_T_end, conc_i_D_end, 3);
%     colors_31(:, :, 2) = Z_2_k31+0.1;
%     colors_31(:, :, 3) = (Z_2_k31+0.1)*0.5;
%     colors_32 = zeros(conc_i_T_end, conc_i_D_end, 3);
%     colors_32(:, :, 1) = 1;
%     colors_32(:, :, 2) = 1-(Z_2_k32+0.1);
%     surf(X, Y, Z_2_k31, colors_31, 'FaceColor', 'interp'); 
%     hold on
%     surf(X, Y, Z_2_k32, colors_32, 'FaceColor', 'interp');
% %     cmap31 = winter(100);
% %     cmap32 = autumn(100);
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('Avg. Force');
%     title(['[ATP] vs. [ADP] vs. prob 3->1 and prob 1->3']);
%     
%     % Plot Residence Times in State 3
%     figure(205)
%     Z_2_ResTime3 = log10(TvD_store(x_range, y_range,7)*1e3); %reshape(excel_op_store(:,6), conc_i_end, conc_i_end);
%     surf(X, Y, Z_2_ResTime3, 'FaceColor', 'interp');  
%     hold on
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('St. 3 Res. Time (log10(ms))');
%     cb = colorbar;
%     caxis([0,5]);
%     title(['[ATP] vs. [ADP] vs. State 3 Res. Time (log10(ms))']);
    
    
    
%     %Plot cycle times for 2 myosin system
%     figure(220)
%     for m = 1:m_nodes
%         surf(X, Y, TvD_mult_store(:, :, m));
%         hold on
%     end
%     xlabel('log([ATP]) M');
%     ylabel('log([ADP*Pi]) M');
%     zlabel('Cycle Time (ms)');
%     cb = colorbar;
%     caxis([0, 100]);
%     cb.Label.String = 'Cycle Time (ms)';
%     title(['[ATP] vs. [ADP*Pi] vs. Cycle Time (ms)']);
%}    

%% 3D Plot of cycle times vs ATP/ADP
%store avg_cycle_time_avg
% TvD_store(cf_ATP, cf_ADP, 1) = round(avg_t_cycle_avg*1e3, 2); 
% %store avg_avg_F_output
% TvD_store(cf_ATP, cf_ADP, 2) = round(avg_avg_F_output, 2, 'significant'); 
% %store K23
% TvD_store(cf_ATP, cf_ADP, 3) = K23_store(find(K23_store, 1, 'first')); 
% %store k31
% TvD_store(cf_ATP, cf_ADP, 4) = k31_store(find(k31_store, 1, 'first'));
% %store duty ratio
% TvD_store(cf_ATP, cf_ADP, 5) = round(avg_duty_ratio, 2, 'significant');
% %store ATP/s
% TvD_store(cf_ATP, cf_ADP, 6) = round(avg_ATP_per_time, 0);
%{
figure(300)
plot(TtoD_ratio, TvD_store(:,:,1));
hold on
xlabel('[ATP]/[ADP]');
ylabel('cycle times');
title(['[ATP] vs. [ADP] vs. cycle times']);

figure(301)
plot(TtoD_ratio, TvD_store(:,:,5));
hold on
xlabel('[ATP]/[ADP]');
ylabel('cycle times');
title(['[ATP] vs. [ADP] vs. duty ratio']);

figure(302)
plot(TtoD_ratio, TvD_store(:,:,6));
hold on
xlabel('[ATP]/[ADP]');
ylabel('cycle times');
title(['[ATP] vs. [ADP] vs. ATP/s']);

figure(303)
plot(TtoD_ratio, TvD_store(:,:,2));
hold on
xlabel('[ATP]/[ADP]');
ylabel('cycle times');
title(['[ATP] vs. [ADP] vs. Avg. Force']);

figure(304)
    Z_k31 = TvD_store(:,:,4); %reshape(excel_op_store(:,9), conc_i_end, conc_i_end);
    Z_K23 = TvD_store(:,:,3); %reshape(excel_op_store(:,8), conc_i_end, conc_i_end);
    Z_k32 = 300./Z_K23;
    Z_2_k31 = Z_k31./(Z_k31+Z_k32)*0.9;
    Z_2_k32 = Z_k32./(Z_k31+Z_k32)*0.9;
plot(TtoD_ratio, TvD_store(:,:,4), 'g'); %k31
plot(TtoD_ratio, 300./TvD_store(:,:,3), 'r'); %k32
hold on
xlabel('[ATP]/[ADP]');
ylabel('cycle times');
title(['[ATP] vs. [ADP] vs. ATP/s']);
%}
    

%% Plots
if create_plots == true
 

    %***NOTE: when plotting, F_output(1, t_index) is producing the F_output at time = (t_index - 1) (since t_index began indexing at 1, not 0, so t_index = realtime + 1)
    %Plot F_output
%     figure(11)
%     plot(t(t_index), F_output(1, t_index), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%     hold on;
%     %xlabel('Time (\mus)'); 
%     xlabel('Time (s)'); 
%     %ylabel('(nm)');
%     ylabel('F_{output} (pN)');
%     title('F_{output} vs. time');

    
%     node_symbol = ['o', 'o', 'o', '*', '*', '*'];
%     node_color = ['r', 'r', 'r', 'b', 'b', 'b'];

    %Plot Node locations vs. time
    %uncomment
    %{
    figure(13)
    %plot(t(t_index).*ones(1, 3), N_locations(t_index+1, 1:a_nodes+1)*(1e9), 'ro', t(t_index).*ones(1, 3), N_locations(t_index+1, a_nodes+2:tot_nodes)*(1e9), 'b*');
    plot(N_locations(t_index+1, 1:a_nodes+1)*(1e9), t(t_index).*ones(1, a_nodes+1), 'ro',  N_locations(t_index+1, a_nodes+2:tot_nodes)*(1e9),t(t_index).*ones(1, m_nodes+1), 'b*');
    %'Marker', node_symbol, 'MarkerFaceColor', node_color);
    hold on
%     plot((((V(tot_nodes-1)+km*m0)/(-kF))+xf0)*(1e9), t(t_index), 'gx');
    ylabel('Time (s)');
    xlabel('Node locations (nm)');
    title('Node locations vs. time; red = actin, blue = myosin');
    %}
    
    %Plot Node locations vs. time AFTER SIMULATION
    %%{
    figure(13)
    N_locations_aplot = N_locations(1:end, 1:a_nodes+1);
    N_locations_mplot = N_locations(1:end, a_nodes+2:tot_nodes);
    plot(N_locations_aplot*(1e9), repmat(t.', 1, a_nodes+1), 'ro', 'MarkerSize', 3);
    hold on
    plot(N_locations_mplot*(1e9), repmat(t.', 1, m_nodes+1), 'b*', 'MarkerSize', 4);
    hold on
    ylabel('Time (s)');
    xlabel('Node locations (nm)');
    title('Node locations vs. time; red = actin, blue = myosin');
    %}
    
    %Plot location of M-line node location
%     figure(14) %output of locations plotted in nm
%     plot(N_locations(:, end)*(1e9), t.', 'g.');
%     hold on;
%     ylabel('Time (s)'); 
%     xlabel('M-line location (nm)');
%     xlim([0, N_locations(1, end)*(1e9)+2]);
%     title('M-line location vs. time');

    %Plot ATPase activity
    %{
    figure(15)
    yyaxis left
    plot(t(t_index), sum(ATPase_tracker(1, :)), '-bo');
    hold on
%     yyaxis right
%     ylabel('Power (J/ms)');
%     plot(t(t_index), work_store(t_index, 1)*1e7/dt, '-gp');
%     plot(t(t_index+1), sum((work_store(:, 1)*1e7)./dt), 'kp');
    ylabel('Cumulative ATP hydrolyzed (molecules)');
    xlabel('Time (s)');
    hold on
    yyaxis right
    %Plot Total ATP consumed/time
    if mod(t_index, 20) == 0
        plot(t(t_index), sum(ATPase_tracker(1,:))/(t_index*dt), '*k');
    end
    ylabel('Total ATP consumed/ms');
    title('Cumulative ATPase activity');
    %}
    
    %% Plot ATPase activity AFTER SIMULATION
    %%{
    figure(15)
    yyaxis left
    plot(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 'bo');
    hold on
% Plot Best fit line
    lreqns_x_coord = t_end_true/2; %x coord of linear regression equations, used below
    lreqns_y_coord = ATPase_tracker_plot(floor((tot_timesteps-1)/2))/2;
    %Find the indices of t that mark the start and end of the external applied Force (F_ext)
% % % % % % % % %     t_index_appforce = find(t > t_appforce, 1, 'first');
% % % % % % % % %     t_index_removeforce = find(t < t_removeforce, 1, 'last') + 1;
% % % % % % % % %     if t_index_removeforce >= tot_timesteps
% % % % % % % % %         t_index_removeforce = tot_timesteps-1;
% % % % % % % % %     end
%{ 
    %was removed 12/20/2021 because of bug in the way, can undo and debug if needed again
%     if t_appforce > 0
%         %{
%         %(1) Piecewise trendline (1) 1:t_appforce-1 --> (2) t_appforce:t_removeforce-1 --> (3) t_removeforce:tot_timesteps-1
%         %Using ATPase activity values at each timestep
%         [coeff1, S1] = polyfit(t(1:t_index_appforce-1), ATPase_tracker_plot(1:t_index_appforce-1), 1);
%         [ATPase_lr1, ~] = polyval([coeff1(1), coeff1(2)], t(1:t_index_appforce-1), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(t(1:t_index_appforce-1), ATPase_lr1, '--c', 'LineWidth', 2);
%         RMSE1 = sqrt(mean((ATPase_lr1 - ATPase_tracker_plot(1:t_index_appforce-1)).^2, 'omitnan'));
%         ATPase_lr1_text = sprintf('y_1 = %.3f x + %.3f (cyan) \nRMSE = %.3f', coeff1(1), coeff1(2), RMSE1); %Convert the equation into text
% %         text(0.5, 450, ATPase_lr1_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         hold on
%         [coeff2, S2] = polyfit(t(t_index_appforce:t_index_removeforce-1), ATPase_tracker_plot(t_index_appforce:t_index_removeforce-1), 1);
%         [ATPase_lr2, ~] = polyval([coeff2(1), coeff2(2)], t(t_index_appforce:t_index_removeforce-1), S2); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(t(t_index_appforce:t_index_removeforce-1), ATPase_lr2, '--m', 'LineWidth', 2);
%         RMSE2 = sqrt(mean((ATPase_lr2 - ATPase_tracker_plot(t_index_appforce:t_index_removeforce-1)).^2, 'omitnan'));
%         ATPase_lr2_text = sprintf('y_2 = %.3f x + %.3f (magenta) \nRMSE1 = %.3f', coeff2(1), coeff2(2), RMSE2); %Convert the equation into text
% %         text(2.5, 150, ATPase_lr2_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         hold on
%         [coeff3, S3] = polyfit(t(t_index_removeforce:tot_timesteps-1), ATPase_tracker_plot(t_index_removeforce:tot_timesteps-1), 1);
%         [ATPase_lr3, ~] = polyval([coeff3(1), coeff3(2)], t(t_index_removeforce:tot_timesteps-1), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(t(t_index_removeforce:tot_timesteps-1), ATPase_lr3, '--c', 'LineWidth', 2);
%         RMSE3 = sqrt(mean((ATPase_lr3 - ATPase_tracker_plot(t_index_removeforce:tot_timesteps-1)).^2, 'omitnan'));
%         ATPase_lr3_text = sprintf('y_3 = %.3f x + %.3f (cyan) \nRMSE2 = %.3f', coeff3(1), coeff3(2), RMSE3); %Convert the equation into text
% %         text(2.5, 0, ATPase_lr3_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         %}
% 
%         %%{
%         %(2) Piecewise trendline (1) 1:t_appforce-1 --> (2) t_appforce:t_removeforce-1 --> (3) t_removeforce:tot_timesteps-1
%         %Using ATPase activity interpolated at time points corresponding to the smallest dt value in the simulation
%         [coeff1, S1] = polyfit(interp_time(1:find(interp_time > t_appforce, 1, 'first')-1), ATPase_tracker_plot_interp(1:find(interp_time > t_appforce, 1, 'first')-1), 1);
%         [ATPase_lr1, ~] = polyval([coeff1(1), coeff1(2)], interp_time(1:find(interp_time > t_appforce, 1, 'first')-1), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(interp_time(1:find(interp_time > t_appforce, 1, 'first')-1), ATPase_lr1, '--c', 'LineWidth', 2);
%         RMSE1 = sqrt(mean((ATPase_lr1 - ATPase_tracker_plot_interp(1:find(interp_time > t_appforce, 1, 'first')-1)).^2, 'omitnan'));
%         ATPase_lr1_text = sprintf('y_1 = %.3f x + %.3f (cyan) \nRMSE = %.3f', coeff1(1), coeff1(2), RMSE1); %Convert the equation into text
% %         text(0.5, 450, ATPase_lr1_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         hold on
%         [coeff2, S2] = polyfit(interp_time(find(interp_time > t_appforce, 1, 'first'):find(interp_time < t_removeforce, 1, 'last') - 1), ATPase_tracker_plot_interp(find(interp_time > t_appforce, 1, 'first'):find(interp_time < t_removeforce, 1, 'last') - 1), 1);
%         [ATPase_lr2, ~] = polyval([coeff2(1), coeff2(2)], interp_time(find(interp_time > t_appforce, 1, 'first'):find(interp_time < t_removeforce, 1, 'last') - 1), S2); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(interp_time(find(interp_time > t_appforce, 1, 'first'):find(interp_time < t_removeforce, 1, 'last') - 1), ATPase_lr2, '--m', 'LineWidth', 2);
%         RMSE2 = sqrt(mean((ATPase_lr2 - ATPase_tracker_plot_interp(find(interp_time > t_appforce, 1, 'first'):find(interp_time < t_removeforce, 1, 'last') - 1)).^2, 'omitnan'));
%         ATPase_lr2_text = sprintf('y_2 = %.3f x + %.3f (magenta) \nRMSE1 = %.3f', coeff2(1), coeff2(2), RMSE2); %Convert the equation into text
% %         text(2.5, 150, ATPase_lr2_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         hold on
%         [coeff3, S3] = polyfit(interp_time(find(interp_time < t_removeforce, 1, 'last'):length(interp_time)), ATPase_tracker_plot_interp(find(interp_time < t_removeforce, 1, 'last'):length(interp_time)), 1);
%         [ATPase_lr3, ~] = polyval([coeff3(1), coeff3(2)], interp_time(find(interp_time < t_removeforce, 1, 'last'):length(interp_time)), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(interp_time(find(interp_time < t_removeforce, 1, 'last'):length(interp_time)), ATPase_lr3, '--c', 'LineWidth', 2);
%         RMSE3 = sqrt(mean((ATPase_lr3 - ATPase_tracker_plot_interp(find(interp_time < t_removeforce, 1, 'last'):length(interp_time))).^2, 'omitnan'));
%         ATPase_lr3_text = sprintf('y_3 = %.3f x + %.3f (cyan) \nRMSE2 = %.3f', coeff3(1), coeff3(2), RMSE3); %Convert the equation into text
% %         text(2.5, 0, ATPase_lr3_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         %}
%         %Combine text output of pre-Fext, peri-Fext, post-Fext Cumulative ATP Hydrolyzed linear regression equations
%         ATPase_lr123_text = [ATPase_lr1_text, newline, ATPase_lr2_text, newline, ATPase_lr3_text];
%         text(lreqns_x_coord, lreqns_y_coord, ATPase_lr123_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
%         
%     else
%         %(1) Calculate linear regression using ATPase activity values at each timestep
%         if ATPase_interp == false
%             %%{
%             % y-intercept not fixed
%             [coeff, S] = polyfit(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 1); %calculates 
%             [ATPase_lr, delta] = polyval([coeff(1), coeff(2)], t, S); %ATPase_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
%             if fix_ATPaselr_int == true            
%                 % y-intercept fixed at origin (0,0)
%                 ATPase_lr_mdl = fitlm(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 'y~x1-1');
%                 ATPase_lr = t*(ATPase_lr_mdl.Coefficients.Estimate);
%                 RMSE_mdl = ATPase_lr_mdl.RMSE;
%             end
%             plot(t, ATPase_lr, '--c', 'LineWidth', 2);
%             if ATPase_RMSE_weighted == false
%                 RMSE = sqrt(mean((ATPase_lr - ATPase_tracker_plot).^2, 'omitnan'));
%             else
%                 RMSE = sqrt(sum((ATPase_lr(1:tot_timesteps-1) - ATPase_tracker_plot(1:tot_timesteps-1)).^2.*(dt_store/t_end_true), 'omitnan'));
%             end
%             %}
%         %(2) Calculate linear regression using ATPase activity interpolated at time points corresponding to the smallest dt value in the simulation
%         else
%             %%{
%             [coeff, S] = polyfit(interp_time, ATPase_tracker_plot_interp, 1); %calculates linear regression coeff using ATPase activity interpolated at time points corresponding to the smallest dt value in the simulation
%             [ATPase_lr, delta] = polyval([coeff(1), coeff(2)], interp_time, S); %ATPase_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
%             plot(interp_time, ATPase_lr, '--c', 'LineWidth', 2);
%             RMSE = sqrt(mean((ATPase_lr - ATPase_tracker_plot_interp).^2, 'omitnan')); %nonweighted <- correct beacuse already interpolated
%             %}
%         end
% %         
%         if fix_ATPaselr_int == true
%             ATPase_lr_text = sprintf('y = %.3fx (cyan) \nRMSE = %.3f \nRMSE_{mdl} = %.3f', coeff(1), RMSE, RMSE_mdl); %Convert the equation into text - intercept = (0,0)
%         else
% %             ATPase_lr_text = sprintf('y = %.3f x + %.3f (cyan) \nRMSE = %.3f', coeff(1), coeff(2), RMSE); %Convert the equation into text
% %             ATPase_lr_text = sprintf('y = %.3f x + %.3f (cyan) \nFvar_{raw} = %.3f \nFvar_{n2pk} = %.3f \nFvar_{n2avg} = %.3f', coeff(1), coeff(2), avg_F_var, avg_F_var_Norm2Peak, avg_F_var_Norm2Avg); %Convert the equation into text
%             ATPase_lr_text = sprintf('y = %.3f x + %.3f (cyan)', coeff(1), coeff(2)); %Convert the equation into text
%         
%         end
%         text(lreqns_x_coord, lreqns_y_coord, ATPase_lr_text, 'FontSize', 9, 'Color', 'k'); %Insert the regression equation into the plot
%     end %if t_appforce > 0
%}    

    %%%ylabel({'Cumulative ATP hydrolyzed (blue) (molecules)'; 'ATPase activity (g) (0: no ATP hydrolyzed; 100: ATP hydrolyzed)'});
    ylabel('Cumulative ATP hydrolyzed (blue) (molecules)');
    xlabel('Time (s)');
    title('Cumulative ATPase activity (blue) and ATP consumed/s (red) vs. Time (s)');
    %Plot Total ATP consumed/time
    yyaxis right
    ATP_consumed_plot = ATPase_tracker_plot(1:20:tot_timesteps-1)./t(1:20:tot_timesteps-1);
    %Calculate a moving average of ATP consumed/s every int_size seconds
    int_size = 50e-3; %interval size of spacing between green points of the moving average of ATP consumed/s
    numb_int = floor(t_end_true/int_size); %number of intervals/points to record data
    t_true_int = [0:int_size:t_end_true];
    bin_counts = histc(t, t_true_int);
    t_int_units = t(cumsum(bin_counts));
    ATP_consumed_movingAvg = diff(ATPase_tracker_plot([1, cumsum(bin_counts)]))./diff(t([1, cumsum(bin_counts)]));
%     ATP_consumed_movingAvg = diff(ATPase_tracker_plot(1:50:tot_timesteps-1))./diff(t(1:50:tot_timesteps-1));
    plot(t(1:20:tot_timesteps-1), ATP_consumed_plot, '*r');
    hold on
    plot(t(cumsum(bin_counts)), ATP_consumed_movingAvg, '*g');
    ylim([-1, max(ATP_consumed_movingAvg)]);
    ylabel('Total ATP consumed/s (red)');
    %}
    
    %Plot Total ATP of all simulations (sum of all simulations) (uses some Force variable from F_discr storage array
    %calculation within simulation loop)
    if totalSimCounter > 1
        figure(150)
        yyaxis left
        t_F_edges_plot = [t_F_bin_s:t_F_bin_s:t_end_true_min]; %from F_discr and ATP_discr calculations
%         plot(t(1:tot_timesteps-1), ATPase_trackerTotalSims(1:tot_timesteps-1), 'bo');
        plot(t_F_edges_plot, ATPase_trackerTotalSims, 'bo');
        hold on
        ylabel('Cumulative ATP hydrolyzed (blue) (molecules)');
        xlabel('Time (s)');
        
        yyaxis right
        %Plot Total ATP consumed/time for contraction cycle (not moving average) - point every aATP_period TIMESTEPS
%         aATP_period = 20; %discrete value of aATP_period -> every 20 timesteps there is a point
        aATP_period = round((n_F_edges/300),0); %variable value of aATP_period -> ~300 total points per graph
                                                %n_F_edges is number of F_discr bin edges in F_discr calculation i.e. length (t_F_edges)
        aATP_t = t_F_edges_plot(aATP_period:aATP_period:length(t_F_edges_plot)); %actual time points at which to take average
        ATP_consumed_TotalSims = ATPase_trackerTotalSims(aATP_period:aATP_period:length(ATPase_trackerTotalSims))./aATP_t; 
        hold on
        plot(aATP_t, ATP_consumed_TotalSims, '*r' , 'MarkerSize', 6); %plot non-moving average of F_output
        hold on
        %Plot Total ATP consumed/time (moving average) - point every aATP_int_s SECONDS
        aATP_int_s = 50e-3; %works when this value is greater than t_F_bin_s and a multiple of t_F_bin_s
%         numb_int = floor(t_end_true_min/aATP_int_s);
        aATP_t_true_int = [0:aATP_int_s:t_end_true_min]; %interval total time by an even number of intervals based on aATP_int_size
        aATP_bin_countsTotalSims = discretize(aATP_t_true_int, t_F_edges_plot); %indices of bins of t_F_edges_plot that each value of aATP_t_true_int fall into
        if isnan(aATP_bin_countsTotalSims(1))
            aATP_bin_countsTotalSims = [1, aATP_bin_countsTotalSims(~isnan(aATP_bin_countsTotalSims))];
        end
        %need a vector of times at which to take the moving average points ==> aATP_t_true_int
        %need a vector of indices of ATPase_trackerTotalSims with the ATP values at aATP_t_true_int times ==> aATP_bin_countsTotalSims = discretize(aATP_t_true_int, t_F_edges_plot);       
        i = 1; %initialize i; ind_F_bin(i) = index of t at the end of each bin
%         k = 1; %initialize k; the starting index of each bin
        while i <= length(aATP_bin_countsTotalSims)-1 %Go through and take the average of the ATP consumption within each bin 
            ind_span = [aATP_bin_countsTotalSims(i),aATP_bin_countsTotalSims(i+1)]; %create the span of indicies in t over which to take the average ATP consumption (indices span a aATP_int_s (e.g. 50e-3 s) span)
            avg_mov_ATP_consumed_TotalSims(i) = diff(ATPase_trackerTotalSims(ind_span))/aATP_int_s; %(diff(t_F_edges_plot(ind_span))); %denominator should be equal to (aATP_int_s - t_F_bin_s) % Find time-weighted average ATP consumption over the above indicies 
            i = i + 1; %update i 
%             k = aATP_bin_countsTotalSims(i) + 1;   %update i so that the next average does not include the previous bin's latter bin edge e.g. previous bin: [2:7]; next bin:[8:13]
                                                   %note that i has already been incremented by in last line
        end
        %Get moving average of ATP_consumed_TotalSims that is discretized every aATP_int_s seconds
        %{
        i = 1; %initialize i; ind_F_bin(i) = index of t at the end of each bin
        while i <= length(aATP_bin_countsTotalSims)-1 %Go through and take the average of the ATP consumption within each bin 
            ind_span = aATP_bin_countsTotalSims(i):aATP_bin_countsTotalSims(i+1);
            clear amATP_v1 amATP_v2
            for j = 1:length(ind_span)
                amATP_v1(j) = min([t_F_edges_plot(i+1), t(ind_span(j)+1)]);
                amATP_v2(j) = max([t_F_edges_plot(i), t(ind_span(j))]);
            end
            amATP_v0 = ATPase_trackerTotalSims(ind_span);
            amATP_v3 = t(ind_span+1) - t(ind_span);
            avg_mov_ATP_consumed_TotalSims(i) = sum(amATP_v0.*((amATP_v1 - amATP_v2)./amATP_v3));
            i = i+1;
        end
        %}
        aATP_int_t = [aATP_int_s:aATP_int_s:t_end_true_min];
        plot(aATP_int_t, avg_mov_ATP_consumed_TotalSims, '*g' , 'MarkerSize', 6); %plot non-moving average of F_output
        ylabel('Total ATP consumed/s (red)');
        f150_title1 = ['Cumulative ATPase act. (blu) & ATP/s_{total} (r) & ATP/s_{mov. avg. (',num2str(aATP_int_s), ' s)} (g)'];
        f150_title2 = ['vs. Time (s) for n = ', num2str(n_sim), ' simulations'];
        title([convertCharsToStrings(f150_title1), convertCharsToStrings(f150_title2)]);
        
        % Further analysis of Cumulative ATPase activity (ATPase_trackerTotalSims)
        tot_ATPase_trackerTotSims = max(ATPase_trackerTotalSims);
        avgATP_perSarc = tot_ATPase_trackerTotSims/totalSimCounter;
        avgATP_perMyo = tot_ATPase_trackerTotSims/(totalSimCounter*m_nodes);
        
        % Further analysis of ATP Consumed/time across Total Sims (not moving avg) (ATP_consumed_TotalSims)
%         diff_ATPConsTotSims = diff(ATP_consumed_TotalSims);
%         [hist_ATPConsTotSims,edges_ATPConsTotSims] = histcounts(ATP_consumed_TotalSims);
%         platStart_ATPConsTotSims = max(cumsum(hist_ATPConsTotSims(1:find(hist_ATPConsTotSims == max(hist_ATPConsTotSims))-1)));
%         plat_ATPConsTotSims = mean(ATP_consumed_TotalSims((platStart_ATPConsTotSims+1):end));
%         platStart_ATPConsTotSims = find(ATP_consumed_TotalSims >= mean(ATP_consumed_TotalSims(end-100:end)), 1, 'first');
        platStart_ATPConsTotSims = find(ATP_consumed_TotalSims >= 0.98*max(ATP_consumed_TotalSims), 1, 'first');
        plat_ATPConsTotSims = mean(ATP_consumed_TotalSims(platStart_ATPConsTotSims:end), 'omitnan');
        ATPConsTotSims_perSarc = plat_ATPConsTotSims/(totalSimCounter);
        ATPConsTotSims_perMyo = plat_ATPConsTotSims/(totalSimCounter*m_nodes);
        
        % Further analysis of moving avg ATP Consumed/time across Total Sims (avg_mov_ATP_consumed_TotalSims)
        var_amATPConsTotSims = var(avg_mov_ATP_consumed_TotalSims(2:end), 'omitnan');
        
        
        %Plot Total ATP consumed/time
        %{
%         yyaxis right 
%         ATP_consumed_TotalSims = ATPase_trackerTotalSims(1:20:length(ATPase_trackerTotalSims))./t(1:20:length(ATPase_trackerTotalSims));
%         %Calculate a moving average of ATP consumed/s every int_size seconds
%         int_size = 50e-3; %interval size of spacing between green points of the moving average of ATP consumed/s
%         numb_int = floor(t_end_true_min/int_size); %number of intervals/points to record data
%         t_true_int = [0:int_size:t_end_true_min]; %interval total time by an even number of intervals based on int_size
%         bin_counts = histc(t, t_true_int); %Find how many of each value within t lie in each bin (because t is sequential, this also marks the bin edges)
%         t_int_units = t(cumsum(bin_counts)); %bin edges in seconds
%         ATP_consumed_movingAvgTotalSims = diff(ATPase_trackerTotalSims([1, cumsum(bin_counts)]))./diff(t([1, cumsum(bin_counts)]));
% %         ATP_consumed_movingAvgTotalSims = diff(ATPase_trackerTotalSims([1, cumsum(bin_counts)]))./diff(t([1, cumsum(bin_counts)]));
%     %     ATP_consumed_movingAvg = diff(ATPase_tracker_plot(1:50:tot_timesteps-1))./diff(t(1:50:tot_timesteps-1));
%         plot(t(1:20:length(ATPase_trackerTotalSims)), ATP_consumed_TotalSims, '*r');
%         hold on
%         plot(t(cumsum(bin_counts)), ATP_consumed_movingAvgTotalSims, '*g');
%         ylim([-1, max(ATP_consumed_movingAvgTotalSims)]);
%         ylabel('Total ATP consumed/s (red)');
        %}
    end
    
% Figure 153
% Plot zoomed in portion cumulative ATPase hydrolyzed with regression line while ATP usage reaches a steady state
%{
fig153start = floor(tot_timesteps/2);
% fig153start = 3777;
figure(153)
    plot(t(fig153start:fig153start+40), ATPase_tracker_plot(fig153start:fig153start+40), 'bo');
%     plot(t(100:110), ATPase_tracker_plot(100:110), 'bo');
    hold on
    plot(t(fig153start:fig153start+40), ATPase_lr(fig153start:fig153start+40), '--c', 'LineWidth', 2)
    ylabel('Cumulative ATP hydrolyzed (blue) (molecules)');
    xlabel('Time (s)');
    title('Cumulative ATPase activity vs. Time (s)');
    figure152trans = N_states(fig153start:fig153start+20, 2:3);
    figure152trans(:, 3:4) = N_states(fig153start+21:fig153start+41, 2:3);
 %}

% Figures 151 and 152
% Separate plots for ATPase activity (151) cumulative ATPase activity and (152) ATP consumed/s
 %{
    figure(151)
    plot(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 'bo');
    hold on
    % Plot instantaneous derivative of cumulative ATP hydrolyzed plot (either 0 or 1)
    %%%plot(t, ATPase_tracker*100, 'og');
% Plot Best fit line
%     ATPase_lr = lsline;
%     ATPase_lr.Color = 'c';
%     ATPase_lr.LineWidth = 2;
%     ATPase_lr = fitlm(t, ATPase_tracker_plot, 'Intercept', false);
%     plot(ATPase_lr); 
%     coeff = t(1:tot_timesteps-1).'\ATPase_tracker_plot(1:tot_timesteps-1).';
%     ATPase_lr = coeff*t;
%     plot(t, ATPase_lr, '-c', 'LineWidth', 3);
    % Calculate coefficients of linear regression line y = Bx
%     lreqns_x_coord = t_end/2; %x coord of linear regression equations, used below
%     lreqns_y_coord = ATPase_tracker_plot(floor((tot_timesteps-1)/2))/2;
    lreqns_x_coord = t_end_true/2; %x coord of linear regression equations, used below
    lreqns_y_coord = ATPase_tracker_plot(floor((tot_timesteps-1)/2))/2;
    %Find the indices of t that mark the start and end of the external applied Force (F_ext)
    t_index_appforce = find(t > t_appforce, 1, 'first');
    t_index_removeforce = find(t < t_removeforce, 1, 'last') + 1;
    if t_appforce > 0
        %Piecewise trendline (1) 1:t_appforce-1 --> (2) t_appforce:t_removeforce-1 --> (3) t_removeforce:tot_timesteps-1
%         [coeff1, S1] = polyfit(t(1:t_appforce/dt-1), ATPase_tracker_plot(1:t_appforce/dt-1), 1);
%         [ATPase_lr1, ~] = polyval([coeff1(1), coeff1(2)], t(1:t_appforce/dt-1), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
%         plot(t(1:t_appforce/dt-1), ATPase_lr1, '--c', 'LineWidth', 2);
%         RMSE1 = sqrt(mean((ATPase_lr1 - ATPase_tracker_plot(1:t_appforce/dt-1)).^2, 'omitnan'));
        [coeff1, S1] = polyfit(t(1:t_index_appforce-1), ATPase_tracker_plot(1:t_index_appforce-1), 1);
        [ATPase_lr1, ~] = polyval([coeff1(1), coeff1(2)], t(1:t_index_appforce-1), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
        plot(t(1:t_index_appforce-1), ATPase_lr1, '--c', 'LineWidth', 2);
        RMSE1 = sqrt(mean((ATPase_lr1 - ATPase_tracker_plot(1:t_index_appforce-1)).^2, 'omitnan'));
        ATPase_lr1_text = sprintf('y_1 = %.3f x + %.3f (cyan) \nRMSE = %.3f', coeff1(1), coeff1(2), RMSE1); %Convert the equation into text
%         text(0.5, 450, ATPase_lr1_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
        hold on
        [coeff2, S2] = polyfit(t(t_index_appforce:t_index_removeforce-1), ATPase_tracker_plot(t_index_appforce:t_index_removeforce-1), 1);
        [ATPase_lr2, ~] = polyval([coeff2(1), coeff2(2)], t(t_index_appforce:t_index_removeforce-1), S2); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
        plot(t(t_index_appforce:t_index_removeforce-1), ATPase_lr2, '--m', 'LineWidth', 2);
        RMSE2 = sqrt(mean((ATPase_lr2 - ATPase_tracker_plot(t_index_appforce:t_index_removeforce-1)).^2, 'omitnan'));
        ATPase_lr2_text = sprintf('y_2 = %.3f x + %.3f (magenta) \nRMSE1 = %.3f', coeff2(1), coeff2(2), RMSE2); %Convert the equation into text
%         text(2.5, 150, ATPase_lr2_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
        hold on
        [coeff3, S3] = polyfit(t(t_index_removeforce:tot_timesteps-1), ATPase_tracker_plot(t_index_removeforce:tot_timesteps-1), 1);
        [ATPase_lr3, ~] = polyval([coeff3(1), coeff3(2)], t(t_index_removeforce:tot_timesteps-1), S1); %ATPase_lr is the set of y values of the regression line for each time t; ~ is the est. standard error at each t (individual values of RSME)
        plot(t(t_index_removeforce:tot_timesteps-1), ATPase_lr3, '--c', 'LineWidth', 2);
        RMSE3 = sqrt(mean((ATPase_lr3 - ATPase_tracker_plot(t_index_removeforce:tot_timesteps-1)).^2, 'omitnan'));
        ATPase_lr3_text = sprintf('y_3 = %.3f x + %.3f (cyan) \nRMSE2 = %.3f', coeff3(1), coeff3(2), RMSE3); %Convert the equation into text
%         text(2.5, 0, ATPase_lr3_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
        %Combine text output of applied force and removed force linear regression equations
%         ATPase_lr23_text = append(ATPase_lr2_text, newline, ATPase_lr3_text);
%         text(2.5, 150, ATPase_lr23_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
        
        %Combine text output of pre-Fext, peri-Fext, post-Fext Cumulative ATP Hydrolyzed linear regression equations
        ATPase_lr123_text = [ATPase_lr1_text, newline, ATPase_lr2_text, newline, ATPase_lr3_text];
        text(lreqns_x_coord, lreqns_y_coord, ATPase_lr123_text, 'FontSize', 8, 'Color', 'k'); %Insert the regression equation into the plot
        
    else
        [coeff, S] = polyfit(t(1:tot_timesteps-1), ATPase_tracker_plot(1:tot_timesteps-1), 1);
        [ATPase_lr, delta] = polyval([coeff(1), coeff(2)], t, S); %ATPase_lr is the set of y values of the regression line for each time t; delta is the est. standard error at each t (individual values of RSME)
        plot(t, ATPase_lr, '--c', 'LineWidth', 2);
        RMSE = sqrt(mean((ATPase_lr - ATPase_tracker_plot).^2, 'omitnan'));
        ATPase_lr_text = sprintf('y = %.3f x + %.3f (cyan) \nRMSE = %.3f', coeff(1), coeff(2), RMSE); %Convert the equation into text
        text(lreqns_x_coord, lreqns_y_coord, ATPase_lr_text, 'FontSize', 9, 'Color', 'k'); %Insert the regression equation into the plot
    end
    
    %%%ylabel({'Cumulative ATP hydrolyzed (blue) (molecules)'; 'ATPase activity (g) (0: no ATP hydrolyzed; 100: ATP hydrolyzed)'});
    ylabel('Cumulative ATP hydrolyzed (molecules)');
    xlabel('Time (s)');
    title('Cumulative ATPase activity vs. Time (s)');
    
    
    %Plot Total ATP consumed/time
    figure(152)
    ATP_consumed_plot = ATPase_tracker_plot(1:20:tot_timesteps-1)./t(1:20:tot_timesteps-1);
    plot(t(1:20:tot_timesteps-1), ATP_consumed_plot, 'ok');
    ylim([-1, max(ATP_consumed_plot) + max(ATP_consumed_plot)/4]);
    xlabel('Time (s)');
    ylabel('Total ATP consumed/s (molecules/s)');
    title('ATP consumed/s vs. Time (s)');
   %}
    
    %Plot Work, should only be positive when M-line is departing from rest length, either contraction or stretching
%     figure(17)
%     yyaxis left
%     plot(t(t_index), work_store(t_index, 1)*1e7, '-cp');
% %     plot(t(t_index), sum(work_store(:, 1))*1e7, 'ks');
%     ylabel('Work (J)');
%     hold on
%     ylim([-0.01, 0.2]);
%     yyaxis right
% %     plot(t(t_index), N_locations(t_index+1, end)*(1e9), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
% %     ylabel('M-line location (nm)');
%     plot(t(t_index), F_output(1, t_index), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%     ylabel('F_{output} (pN)');
%     %plot(t(t_index), sum(ATPase_tracker(1, :)), '-bo');
%     xlabel('Time (ms)');
% %     ylabel('Work (J)');
%     %title('Work (red) & Cumulative Work (black) vs. Time');
%     title('Work (cyan) and F_{output} vs. Time');

    %Plot Work and Work/ATP AFTER SIMULATION
%     figure(17)
%     yyaxis left
%     plot(t, work_store, 'kp'); 
%     ylabel('Work (J)');
%     hold on
%     yyaxis right
% %     plot(work_per_ATP(:,1), work_per_ATP(:,2), 'bo');
% %     plot(t, work_per_ATP(:,1), 'bo');
%     work_per_ATP = (work_store((mod(t./dt, 20)==0)).')./ATPase_tracker_plot((mod(t./dt, 20)==0));
%     plot(t(mod(t./dt, 20)==0), work_per_ATP, 'bo');
% %     ylim([-0.01, 0.2]);
%     hold on
%     ylabel('Work/ATP (J/ATP)');
%     xlabel('Time (ms)');
%     title('Work (black) and Work/ATP (blue)');   % and F_{output} vs. Time');
    
    
%Plot F_output (left axis)
%Plot Average Force throughout simulation (Force generated at that time/time elapsed vs. time) (right axis)

if m_nodes == 2 && a_nodes == 2
    m_states = N_states(:, a_nodes+2:tot_nodes-1);
    stc = [1 0 0; 0 0 1; 0 0 0]; %state color
    stm = ['*', 'o', '^']; %state marker
    m4_1 = m_states(:,1) == 1;
    m4_2 = m_states(:,1) == 2;
    m4_3 = m_states(:,1) == 3;
    %Create a matrix of all the colors corresponding to the state of m4 (red = m4 in state 1; blue = m4 in state 2; black = m4 in state 3)
    m_colors = zeros(tot_timesteps, 3);
    m_colors(m4_1, :) = repmat(stc(1,:), size(find(m4_1 == 1), 1), 1); %red
    m_colors(m4_2, :) = repmat(stc(2,:), size(find(m4_2 == 1), 1), 1); %blue
    m_colors(m4_3, :) = repmat(stc(3,:), size(find(m4_3 == 1), 1), 1); %black
    m5_1 = m_states(:,2) == 1;
    m5_2 = m_states(:,2) == 2;
    m5_3 = m_states(:,2) == 3;
 % Plot F_output AFTER SIMULATION
    % Reference: colorcode = {'r*', 'ro', 'r^';'b*', 'bo', 'b^' ; 'k*', 'ko', 'k^'}; %[1,1 1,2 1,3 ; 2,1 2,2 2,3 ; 3,1 3,2 3,3]
    figure(16)
    % 3 plot statements, plot all same symbol with different colors
    scatter(t(m5_1), F_output(m5_1), [], m_colors(m5_1, :), stm(1)); %star symbol (m5 in state 1)
    hold on
    scatter(t(m5_2), F_output(m5_2), [], m_colors(m5_2, :), stm(2)); %circle symbol (m5 in state 2)
    hold on
    scatter(t(m5_3), F_output(m5_3), [], m_colors(m5_3, :), stm(3)); % triangle symbol (m5 in state 3)
    hold on
    ylabel('F_{output} (pN)');
    % Plot of M-line location (now moved to figure 17)
%     yyaxis right
%     plot(t.', N_locations(:, end)*(1e9), 'Color', [0.4940 0.1840 0.5560], 'Marker', '.', 'Linestyle', 'none');
%     ylabel('M-line location (nm)');
%     ylim([0, N_locations(1, end)*(1e9)+2]);
    xlabel('Time (s)');
    title('F_{output} vs. Time ft. Avg. F_{output}');
    hold on
    % Plot periodic average force onto same figure
    af_period = round((tot_timesteps/100), 0);
%     avg_F_output_periodic = arrayfun(@(i) mean(F_output(i:i+af_period-1)), 2:af_period:length(F_output)-af_period+1)'; % the averaged force vector
    avg_F_output_periodic = arrayfun(@(i) sum(F_output(i:i+af_period-1).*(dt_store(i:i+af_period-1)./sum(dt_store(i:i+af_period-1)))), 1:af_period:length(F_output)-af_period+1)'; % the weighted averaged force vector
    avg_Fop_t = t(af_period:af_period:length(t));
    plot(avg_Fop_t, avg_F_output_periodic, '-gd' , 'MarkerFaceColor', 'g', 'MarkerSize', 3);

% Histogram of iterations spent in each state for 2 myosin system
% % % % % % % % %     figure(18)
% % % % % % % % %     %The below values are also calculated above when constructing figure 15 - ATPase activity
% % % % % % % % %     t_index_appforce = find(t > t_appforce, 1, 'first');
% % % % % % % % %     t_index_removeforce = find(t < t_removeforce, 1, 'last') + 1;
% % % % % % % % %     if t_index_removeforce >= tot_timesteps
% % % % % % % % %         t_index_removeforce = tot_timesteps-1;
% % % % % % % % %     end
% % % % % % % % %     % Left to right (m1, m2) = (1, 1) (1, 2) (1, 3) (2, 1) (2, 2) (2, 3) (3, 1) (3, 2) (3, 3)
% % % % % % % % %     % This one: Left to right (m1, m2) = (1, 1) (1, 2) (2, 1) (2, 2) (2, 3) (3, 2) (1, 3) (3, 1) (3, 3)
% % % % % % % % %     stm1m2 = [sum(m4_1 == m5_1 & m4_1 == 1 & m5_1 == 1)-t_Ca; sum(m4_1 == m5_2 & m4_1 == 1 & m5_2 == 1); sum(m4_2 == m5_1 & m4_2 == 1 & m5_1 == 1); sum(m4_2 == m5_2 & m4_2 == 1 & m5_2 == 1);...
% % % % % % % % %         sum(m4_2 == m5_3 & m4_2 == 1 & m5_3 == 1); sum(m4_3 == m5_2 & m4_3 == 1 & m5_2 == 1); sum(m4_1 == m5_3 & m4_1 == 1 & m5_3 == 1); sum(m4_3 == m5_1 & m4_3 == 1 & m5_1 == 1); sum(m4_3 == m5_3 & m4_3 == 1 & m5_3 == 1)];
% % % % % % % % % %     length(intersect(find(m4_1 == 1), find(m5_1 == 1)))
% % % % % % % % %     stm1m2_text = {'(1, 1)' , '(1, 2)', '(2, 1)', '(2, 2)', '(2, 3)', '(3, 2)', '(1, 3)', '(3, 1)', '(3, 3)'};
% % % % % % % % %     bar(stm1m2);
% % % % % % % % %     hold on
% % % % % % % % %     set(gca, 'XTick', 1:9, 'XTickLabel', stm1m2_text);
% % % % % % % % % %     text(1:length(stm1m2), stm1m2, num2str(stm1m2),'vert','bottom','horiz','center'); %Gives raw # iterations
% % % % % % % % % %     text(1:length(stm1m2), stm1m2, num2str(round(stm1m2./(tot_timesteps - (t_removeforce/dt - t_appforce/dt)),
% % % % % % % % % %     3)),'vert','bottom','horiz','center'); %Give proportion
% % % % % % % % %     stm1m2_labels = {};
% % % % % % % % %     for i = 1:9
% % % % % % % % %         if t_appforce > 0
% % % % % % % % %             stm1m2_labels{i} = [num2str(stm1m2(i)), newline, num2str(round(stm1m2(i)./(tot_timesteps - (t_index_removeforce - t_index_appforce) - t_Ca), 3))]; 
% % % % % % % % %         else
% % % % % % % % %             stm1m2_labels{i} = [num2str(stm1m2(i)), newline, num2str(round(stm1m2(i)./(tot_timesteps - t_Ca), 3))]; 
% % % % % % % % %         end
% % % % % % % % %     end    
% % % % % % % % %     text(1:length(stm1m2), stm1m2, stm1m2_labels,'vert','bottom','horiz','center');
% % % % % % % % %     
% % % % % % % % %     ylabel(['Number of iterations (total timesteps = ', num2str(tot_timesteps-1), ')']);
% % % % % % % % %     xlabel('Configuration (m1 state, m2 state)');
% % % % % % % % %     title('Iterations spent in each configuration (2 myosin system)');
% % % % % % % % %     
% % % % % % % %     if t_appforce > 0
% % % % % % % %         stm1m2_appforce = [sum(m4_1(t_index_appforce:t_index_removeforce) == m5_1(t_index_appforce:t_index_removeforce) & m4_1(t_index_appforce:t_index_removeforce) == 1 & m5_1(t_index_appforce:t_index_removeforce) == 1)-t_Ca;...
% % % % % % % %             sum(m4_1(t_index_appforce:t_index_removeforce) == m5_2(t_index_appforce:t_index_removeforce) & m4_1(t_index_appforce:t_index_removeforce) == 1 & m5_2(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_2(t_index_appforce:t_index_removeforce) == m5_1(t_index_appforce:t_index_removeforce) & m4_2(t_index_appforce:t_index_removeforce) == 1 & m5_1(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_2(t_index_appforce:t_index_removeforce) == m5_2(t_index_appforce:t_index_removeforce) & m4_2(t_index_appforce:t_index_removeforce) == 1 & m5_2(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_2(t_index_appforce:t_index_removeforce) == m5_3(t_index_appforce:t_index_removeforce) & m4_2(t_index_appforce:t_index_removeforce) == 1 & m5_3(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_3(t_index_appforce:t_index_removeforce) == m5_2(t_index_appforce:t_index_removeforce) & m4_3(t_index_appforce:t_index_removeforce) == 1 & m5_2(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_1(t_index_appforce:t_index_removeforce) == m5_3(t_index_appforce:t_index_removeforce) & m4_1(t_index_appforce:t_index_removeforce) == 1 & m5_3(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_3(t_index_appforce:t_index_removeforce) == m5_1(t_index_appforce:t_index_removeforce) & m4_3(t_index_appforce:t_index_removeforce) == 1 & m5_1(t_index_appforce:t_index_removeforce) == 1);...
% % % % % % % %             sum(m4_3(t_index_appforce:t_index_removeforce) == m5_3(t_index_appforce:t_index_removeforce) & m4_3(t_index_appforce:t_index_removeforce) == 1 & m5_3(t_index_appforce:t_index_removeforce) == 1)];
% % % % % % % %         hold on
% % % % % % % %         bar(stm1m2_appforce, 'r');
% % % % % % % %     %     text(1:length(stm1m2_appforce), stm1m2_appforce,num2str(stm1m2_appforce),'vert','bottom','horiz','center');
% % % % % % % %     %     text(1:length(stm1m2_appforce), stm1m2_appforce,num2str(round(stm1m2_appforce./stm1m2, 3)),'vert','bottom','horiz','center');
% % % % % % % % %         text(1:length(stm1m2_appforce), stm1m2_appforce, num2str(round(stm1m2_appforce./(t_index_removeforce - t_index_appforce), 3)),'vert','bottom','horiz','center');
% % % % % % % %         stm1m2_appforce_labels = {};
% % % % % % % %         for i = 1:9
% % % % % % % %             stm1m2_appforce_labels{i} = [num2str(stm1m2_appforce(i)), newline, num2str(round(stm1m2_appforce(i)./(t_index_removeforce - t_index_appforce), 3))]; 
% % % % % % % %         end
% % % % % % % %         text(1:length(stm1m2_appforce), stm1m2_appforce, stm1m2_appforce_labels,'vert','bottom','horiz','center');
% % % % % % % %     end
    
else %non- '2 myosin + 2 actin' system simulations
    figure(16)
%     yyaxis left
    plot(t, F_output, 'bo');
    hold on
    af_period = round((tot_timesteps/100), 0);
%     avg_F_output_periodic = arrayfun(@(i) mean(F_output(i:i+af_period-1)), 2:af_period:length(F_output)-af_period+1)'; % the averaged force vector
    avg_F_output_periodic = arrayfun(@(i) sum(F_output(i:i+af_period-1).*(dt_store(i:i+af_period-1)./sum(dt_store(i:i+af_period-1)))), 1:af_period:length(F_output)-af_period+1)'; % the averaged force vector - weighted
    avg_Fop_t = t(af_period:af_period:length(t));
    hold on
    
    % ACTIVE FORCE PLOT
%     plot(t, F_active, 'rd', 'MarkerSize', 3); %plot just the ACTIVE FORCE (total force - applied force) in red 
    plot(avg_Fop_t, avg_F_output_periodic, '-gd' , 'MarkerFaceColor', 'g', 'MarkerSize', 3); %plot moving average of F_output
    ylabel('F_{output} (pN)'); 
    xlabel('Time (s)');
    title('F_{output} (blu) & Avg. F_{output} (g) & F_{ext} (bla) & F_{act} (r) vs. Time (s)');

%Further analysis on F_outputTotalSims
        platstart_FopTotSims = find(F_outputTotalSims > mean(F_outputTotalSims), 1, 'first');
        range_FopTotSims = range(F_outputTotalSims(platstart_FopTotSims:end));
        avg_FopTotSims = mean(F_outputTotalSims(platstart_FopTotSims:end));
        avg_FopTotSims_perSarc = avg_FopTotSims/totalSimCounter;
        var_FopTotSims = var(F_outputTotalSims(platstart_FopTotSims:end));
        std_FopTotSims = std(F_outputTotalSims(platstart_FopTotSims:end));
        percFluct_FopTotSims = std_FopTotSims/avg_FopTotSims*100;
        percFluct_FopTotSims_perSarc = percFluct_FopTotSims/totalSimCounter;
    %%{
        %commented out 10-31-22
    if totalSimCounter > 1
        figure(160)
        t_F_edges_plot = [t_F_bin_s:t_F_bin_s:t_end_true_min];
        plot(t_F_edges_plot, F_outputTotalSims, 'bo');
        hold on
        %Old method before force was discretized
%         af_period = round((tot_timesteps/100), 0);
%         avg_F_output_periodicTotalSims = arrayfun(@(i) sum(F_outputTotalSims(i:i+af_period-1).*(dt_store(i:i+af_period-1)./sum(dt_store(i:i+af_period-1)))), 1:af_period:length(F_outputTotalSims)-af_period+1)'; % the averaged force vector - weighted
%         avg_Fop_t = t(af_period:af_period:length(t));
        %New method with discretized force
        afTotalSims_period = round((n_F_edges/100), 0);
        if a_nodes == 1 && m_nodes == 1
            avg_F_output_periodicTotalSims = arrayfun(@(i) sum(F_outputTotalSims(i:i+afTotalSims_period-1).*(t_F_edges(i:i+afTotalSims_period-1)./sum(t_F_edges(i:i+afTotalSims_period-1)))), 1:afTotalSims_period:length(F_outputTotalSims)-afTotalSims_period+1)'; % the averaged force vector - weighted
        else
            avg_F_output_periodicTotalSims = arrayfun(@(i) sum(F_outputTotalSims(i:i+afTotalSims_period-1).*(dt_store(i:i+afTotalSims_period-1)./sum(dt_store(i:i+afTotalSims_period-1)))), 1:afTotalSims_period:length(F_outputTotalSims)-afTotalSims_period+1)'; % the averaged force vector - weighted
        end
        avg_Fop_t = t_F_edges_plot(afTotalSims_period:afTotalSims_period:length(t_F_edges_plot));
        
        hold on
        plot(avg_Fop_t, avg_F_output_periodicTotalSims, '-gd' , 'MarkerFaceColor', 'g', 'MarkerSize', 3); %plot moving average of F_output
        ylabel('F_{outputTOTAL} (pN)'); 
        xlabel('Time (s)');
        title('F_{outputTOTAL} (blu) & Avg. F_{output} (g) vs. Time (s) for ALL simulations');
        
        figure(161)
        histogram(F_outputTotalSims); %, 'FaceColor', 'b');
        hold on
        histogram(F_outputTotalSims(platstart_FopTotSims:end), 'FaceColor', 'r', 'LineStyle', '--', 'FaceAlpha', 0);
        ylabel('ms'); 
        xlabel('F_{output} (pN)');
        title('F_{output} (blu) & Avg. F_{output} (g) vs. Time (s) for ALL simulations');
    end  
    %}

        
%% Multi-sim Data Outputs -> saved per sim -> now averaged to get avg. and std. over n = 10

F_avgAvgSims = mean(F_df_StorePerSim(1, :));
F_stdAvgSims = std(F_df_StorePerSim(1,:));
F_avgStdSims = mean(F_df_StorePerSim(2, :));
F_stdStdSims = std(F_df_StorePerSim(2, :));
percFluct_FopAvgSims = mean(F_df_StorePerSim(3, :));
percFluct_FopStdSims = std(F_df_StorePerSim(3, :));

plat_ATPConsAvgSims = mean(plat_ATPConsPerSim(1, :));
plat_ATPConsStdSims = std(plat_ATPConsPerSim(1, :));

FperATPCons_eaSim = F_df_StorePerSim(1, :)./plat_ATPConsPerSim;
FperATPConsAvgSims = mean(FperATPCons_eaSim); %Average F/(ATP/s)
FperATPConsStdSims = std(FperATPCons_eaSim);

FperATPConsStdSims_manual = (F_avgAvgSims/plat_ATPConsAvgSims)*sqrt((plat_ATPConsStdSims/plat_ATPConsAvgSims)^2 + (F_avgStdSims/F_avgAvgSims)^2);

% Potential Fluctuation Metrics
%%{
if totalSimCounter > 1
    F_opMovAvgPeaks = numel(findpeaks(avg_F_output_periodicTotalSims));
else
    F_opMovAvgPeaks = NaN;
end
Kurt_FopAllSims = kurtosis(F_outputTotalSims(platstart_FopTotSims:end));
if (platstart_FopTotSims + 1000) < length(F_outputTotalSims)
    F_opAllPeaks = numel(findpeaks(F_outputTotalSims(platstart_FopTotSims:platstart_FopTotSims+1000)));
    FluctPerc_FopAllSims = sum((((avg_FopTotSims-F_outputTotalSims(platstart_FopTotSims:platstart_FopTotSims+1000))/avg_FopTotSims)));
    FluctPerc_FopAllSimsPositive = sqrt((sum((avg_FopTotSims-F_outputTotalSims(platstart_FopTotSims:platstart_FopTotSims+1000)).^2)/avg_FopTotSims)); %Percent changes are sqrt(squared) to ensure they are all positive
else
    F_opAllPeaks = numel(findpeaks(F_outputTotalSims(platstart_FopTotSims:end)));
    FluctPerc_FopAllSims = sum((((avg_FopTotSims-F_outputTotalSims(platstart_FopTotSims:end))/avg_FopTotSims)));
    FluctPerc_FopAllSimsPositive = mean((sqrt((avg_FopTotSims-F_outputTotalSims(platstart_FopTotSims:end)).^2)/avg_FopTotSims));
    disp('(platstart_FopTotSims + 1000) < length(F_outputTotalSims) \n');
end
FluctPerc_perATPCons = FluctPerc_FopAllSims/plat_ATPConsAvgSims;
FluctPerc_norm_F_AvgStdSims = FluctPerc_FopAllSims/F_avgStdSims;
FluctPercPositive_perATPCons = FluctPerc_FopAllSimsPositive/plat_ATPConsAvgSims;
FluctPercPositive_norm_F_AvgStdSims = FluctPerc_FopAllSimsPositive/F_avgStdSims;
%================================================================================================================
%Look at last 0.5 s of simulations
%Find peaks of each simulation, then find the average and standard deviation of the peaks data across simulations
t_bin_mult = 500; %value multipled by t_F_bin_s to get the amount of time from the end of each simulation to derive the below values from
%Find average and std of the last 500*t_F_bin_s (discretization timestep) (if t_F_bin_s = 1e-3s then 0.5 seconds) of Force output
Fop_discr_means_eaSim = mean(Fop_discr_store(:, n_F_edges-1-t_bin_mult:n_F_edges-1).'); %n_F_edges-1 gives the index of the shortest time over which F_discr was taken amongst all sims
Fop_discr_stds_eaSim = std(Fop_discr_store(:, n_F_edges-1-t_bin_mult:n_F_edges-1).'); %Find the standard deviation of the last 500*t_F_bin_s (discretization timestep) seconds of each simulations force output
Fop_discr_Kurt_eaSim = kurtosis(Fop_discr_store(:, n_F_edges-1-t_bin_mult:n_F_edges-1).');
for i = 1:totalSimCounter
    Fop_discr_peaks(i) = numel(findpeaks(Fop_discr_store(i, n_F_edges-1-t_bin_mult:n_F_edges-1)));
    FluctPerc_Fop_eaSim_5(i) = sum((((Fop_discr_means_eaSim(i)-Fop_discr_store(i, n_F_edges-1-t_bin_mult:n_F_edges-1))/Fop_discr_means_eaSim(i))));
    FluctPerc_Fop_eaSimPositive_5(i) = sqrt(sum((Fop_discr_means_eaSim(i)-Fop_discr_store(i, n_F_edges-1-t_bin_mult:n_F_edges-1)).^2)/t_bin_mult)/Fop_discr_means_eaSim(i); %Percent changes are sqrt(squared) to ensure they are all positive
%     FluctPerc_Fop_eaSimPositive_5(i) = sum((sqrt(((Fop_discr_means_eaSim(i)-Fop_discr_store(i, n_F_edges-1-t_bin_mult:n_F_edges-1)).^2)/t_bin_mult)/Fop_discr_means_eaSim(i))); %Percent changes are sqrt(squared) to ensure they are all positive
    FluctPercPositive_perATPCons_eaSim_5(i) = FluctPerc_Fop_eaSimPositive_5(i)/plat_ATPConsAvgSims; %Find average and std of the last 0.5 seconds of ATP consumption <- below values make no sense, just a placeholder in
    
%     FluctPerc_Fop_eaSim_5(i) = sum((((F_df_StorePerSim(1, i)-Fop_discr_store(i, n_F_edges-1-t_bin_mult:n_F_edges-1))/F_df_StorePerSim(1, i))));
%     FluctPerc_Fop_eaSimPositive_5(i) = sum((sqrt((F_df_StorePerSim(1, i)-Fop_discr_store(i, n_F_edges-1-t_bin_mult:n_F_edges-1)).^2)/F_df_StorePerSim(1, i))); %Percent changes are sqrt(squared) to ensure they are all positive
%     FluctPercPositive_perATPCons_eaSim_5(i) = FluctPerc_Fop_eaSimPositive_5(i)/plat_ATPConsAvgSims; %Find average and std of the last 0.5 seconds of ATP consumption <- below values make no sense, just a placeholder in
    
end
Fop_discr_AvgMean_eaSim = mean(Fop_discr_means_eaSim);
Fop_discr_StdMean_acrossSims = std(Fop_discr_means_eaSim);
Fop_discr_AvgStd_eaSim = mean(Fop_discr_stds_eaSim);
Fop_discr_StdStd_eaSim = std(Fop_discr_stds_eaSim);
Fop_discr_AvgPeaks_eaSim = mean(Fop_discr_peaks);
Fop_discr_StdPeaks_eaSim = std(Fop_discr_peaks);
Fop_discr_PeaksData = [Fop_discr_AvgPeaks_eaSim, Fop_discr_StdPeaks_eaSim];
Fop_discr_AvgKurtosis_eaSim = mean(Fop_discr_Kurt_eaSim);
Fop_discr_StdKurtosis_eaSim = std(Fop_discr_Kurt_eaSim);
FluctPerc_Fop_AvgeaSim_5 = mean(FluctPerc_Fop_eaSim_5);
FluctPerc_Fop_StdAvg_acrossSims_5 = std(FluctPerc_Fop_eaSim_5);
FluctPerc_Fop_AvgeaSimPositive_5 = mean(FluctPerc_Fop_eaSimPositive_5); %Percent changes are sqrt(squared) to ensure they are all positive
FluctPercPositive_perATPCons_AvgeaSim_5 = mean(FluctPercPositive_perATPCons_eaSim_5);

%Repeat of some of the above metrics, but for the last 500*t_F_bin_s seconds (0.5 s) of each simulation
F_opAllPeaks_5 = numel(findpeaks(F_outputTotalSims(length(F_outputTotalSims)-t_bin_mult:length(F_outputTotalSims))));
%Find average and std of the last 0.5 seconds of ATP consumption <- below 3 values make no sense, just a placeholder in
%case want to use variable naming style for other ATP variables
% ATPase_discr_means_eaSim = mean(ATPase_discr_store(:, n_F_edges-1-t_bin_mult:n_F_edges-1).');
% ATPase_discr_stds_eaSim = std(ATPase_discr_store(:, n_F_edges-1-t_bin_mult:n_F_edges-1).');
% ATPase_discr_AvgMean_eaSim = mean(ATPase_discr_means_eaSim);
% ATPase_discr_AvgStd_eaSim = mean(ATPase_discr_stds_eaSim);
t_bin_mult = floor(0.5/t_ATP_bin_s);
for i = 1:totalSimCounter
    clear ATPase_movAvg_temp
    ATPase_movAvg_temp = [length(ATP_bin_counts)-t_bin_mult:length(ATP_bin_counts)];
    ATPase_movAvg_temp(ATPase_movAvg_temp == 0) = []; %Done to remove cases where the t_bin_mult is the same as length of ATP_bin_counts
    ATPase_movAvg_means_eaSim(i) = mean(ATP_Cons_movAvg_eaSim_store(i, ATPase_movAvg_temp));
    ATPase_movAvg_stds_eaSim(i) = std(ATP_Cons_movAvg_eaSim_store(i, ATPase_movAvg_temp));
end
ATPase_movAvg_AvgMean_eaSim = mean(ATPase_movAvg_means_eaSim);
ATPase_movAvg_StdMean_acrossSims = std(ATPase_movAvg_means_eaSim);
ATPase_movAvg_AvgStd_eaSim = mean(ATPase_movAvg_stds_eaSim);
ATPase_movAvg_StdStd_eaSim = std(ATPase_movAvg_stds_eaSim);

FperATPCons_eaSim_5 = Fop_discr_means_eaSim./plat_ATPConsPerSim; %*1e3; %F/(ATP/s); not this --> %F/(ATP/ms)
FperATPConsAvgSims_5 = mean(FperATPCons_eaSim_5); %Average F/(ATP/s)
FperATPConsStdAvgSims_5 = std(FperATPCons_eaSim_5); % Std. F/(ATP/s)
%================================================================================================================
% Look at variations in force +- 1/2 std. F about the mean
%{
t_ab_AvgMean = mean(t_ab_int_df(1, :))*1e3; %ms
t_ab_AvgStd = mean(t_ab_int_df(2,:))*1e3; %ms
t_ab_StdStd = std(t_ab_int_df(2, :))*1e3; %ms
F_ab_AvgMean = mean(t_ab_int_df(1, :)); %pN
F_ab_AvgStd = mean(t_ab_int_df(2,:)); %pN
F_ab_StdStd = std(t_ab_int_df(2, :)); %pN

%For a single simulation (~20 s), store all values of T (time intervals between +- std F) and plot in violin plot
if t_end_true > 9.3
    t_ab_AvgMean_19 = mean(t_ab_int_long_df(1, :))*1e3; %ms
    t_ab_StdofAvgMean_19 = std(t_ab_int_long_df(1, :))*1e3; %ms
    t_ab_AvgStd_19 = mean(t_ab_int_long_df(2,:))*1e3; %ms
    t_ab_StdStd_19 = std(t_ab_int_long_df(2, :))*1e3; %ms
    AvgSim_AboveBelow_19 = [t_ab_AvgMean_19, t_ab_StdofAvgMean_19, t_ab_AvgStd_19, t_ab_StdStd_19];
end
%}
%================================================================================================================
% Look at Potential Energy (Epot) in units pN*nm of External Spring
%Look at last 0.5 s of simulations
t_bin_mult2 = 500;
Epot_discr_means_eaSim = mean(Epot_discr_store(:, n_F_edges-1-t_bin_mult2:n_F_edges-1).'); %n_F_edges-1 gives the index of the shortest time over which F_discr was taken amongst all sims
Epot_discr_stds_eaSim = std(Epot_discr_store(:, n_F_edges-1-t_bin_mult2:n_F_edges-1).'); %Find the standard deviation of the last 500*t_F_bin_s (discretization timestep) seconds of each simulations force output
Epot_discr_Kurt_eaSim = kurtosis(Epot_discr_store(:, n_F_edges-1-t_bin_mult2:n_F_edges-1).');
for i = 1:totalSimCounter
    Epot_discr_peaks(i) = numel(findpeaks(Epot_discr_store(i, n_F_edges-1-t_bin_mult2:n_F_edges-1)));
    FluctPerc_Epot_eaSim_5(i) = sum((((F_df_StorePerSim(1, i)-Epot_discr_store(i, n_F_edges-1-t_bin_mult2:n_F_edges-1))/F_df_StorePerSim(1, i))));
    FluctPerc_Epot_eaSimPositive_5(i) = sum((sqrt((F_df_StorePerSim(1, i)-Epot_discr_store(i, n_F_edges-1-t_bin_mult2:n_F_edges-1)).^2)/F_df_StorePerSim(1, i))); %Percent changes are sqrt(squared) to ensure they are all positive
    FluctPercPositive_perATPCons_Epot_eaSim_5(i) = FluctPerc_Epot_eaSimPositive_5(i)/plat_ATPConsAvgSims; %Find average and std of the last 0.5 seconds of ATP consumption <- below values make no sense, just a placeholder in
end 
Epot_discr_AvgMean_eaSim = mean(Epot_discr_means_eaSim);
Epot_discr_AvgStd_eaSim = mean(Epot_discr_stds_eaSim);
Epot_discr_StdStd_eaSim = std(Epot_discr_stds_eaSim); 
Epot_discr_AvgPeaks_eaSim = mean(Epot_discr_peaks);
Epot_discr_StdPeaks_eaSim = std(Epot_discr_peaks);
Epot_discr_PeaksData = [Epot_discr_AvgPeaks_eaSim, Epot_discr_StdPeaks_eaSim];
Epot_discr_AvgKurtosis_eaSim = mean(Epot_discr_Kurt_eaSim);
Epot_discr_StdKurtosis_eaSim = std(Epot_discr_Kurt_eaSim);
FluctPerc_Epot_AvgeaSim_5 = mean(FluctPerc_Epot_eaSim_5);
FluctPerc_Epot_AvgeaSimPositive_5 = mean(FluctPerc_Epot_eaSimPositive_5); %Percent changes are sqrt(squared) to ensure they are all positive
FluctPercPositive_perATPCons_Epot_AvgeaSim_5 = mean(FluctPercPositive_perATPCons_Epot_eaSim_5);
%================================================================================================================
% Look at Potential Energy (Epot) in units pN*nm of All Internal Springs 
Epot_IntSprings_AvgMean_eaSim = mean(Epot_IntSprings_Mean_store);
Epot_IntSprings_StdAvgMean_acrossSims = std(Epot_IntSprings_Mean_store);
Epot_IntSprings_AvgStd_eaSim = mean(Epot_IntSprings_Std_store);
Epot_IntSprings_StdStd_eaSim = std(Epot_IntSprings_Std_store);
% Look at Potential Energy (Epot) in units pN*nm of external spring
Epot_ExtSpring_AvgMean_eaSim = mean(Epot_ExtSpring_Mean_store);
Epot_ExtSpring_StdAvgMean_acrossSims = std(Epot_ExtSpring_Mean_store);
Epot_ExtSpring_AvgStd_eaSim = mean(Epot_ExtSpring_Std_store);
Epot_ExtSpring_StdStd_eaSim = std(Epot_ExtSpring_Std_store);
%================================================================================================================

% Look at Displacement of M-line
% Look at last 0.5 s of simulations
%{
t_bin_mult = 500; %assumes discretization was by 1e-3 s
Mline_disp = N_locations(1, tot_nodes)*1e9 - Mline_discr_store; %Mline_disp > 0 means contraction displacement
Mline_disp_means_eaSim = mean(Mline_disp(:, n_F_edges-1-t_bin_mult:n_F_edges-1).'); %n_F_edges-1 gives the index of the shortest time over which F_discr was taken amongst all sims
Mline_disp_stds_eaSim = std(Mline_disp(:, n_F_edges-1-t_bin_mult:n_F_edges-1).'); %Find the standard deviation of the last 500*t_F_bin_s (discretization timestep) seconds of each simulations force outpu

%Mline outputs 
Mline_disp_AvgMean_eaSim = mean(Mline_disp_means_eaSim);
Mline_disp_AvgStd_eaSim = mean(Mline_disp_stds_eaSim);
Mline_disp_AvgRange_eaSim = mean(range(Mline_disp(:, n_F_edges-1-t_bin_mult:n_F_edges-1).'));
Mline_disp_StdRange_eaSim = std(range(Mline_disp(:, n_F_edges-1-t_bin_mult:n_F_edges-1).'));

%Mline outputs per plateau ATP consumption
Mline_dispPerATPCons_eaSim_5 = Mline_disp_means_eaSim./plat_ATPConsPerSim*1e3; %nm/(ATP/ms)
Mline_dispPerATPConsAvgSims_5 = mean(Mline_dispPerATPCons_eaSim_5); %Average nm/(ATP/ms)
Mline_dispPerATPConsStdSims_5 = std(Mline_dispPerATPCons_eaSim_5); % Std. nm/(ATP/ms)
%}
%================================================================================================================
%================================================================================================================
%Store in copy-paste excel vector
AvgSim_ATP_F_data = [plat_ATPConsAvgSims, plat_ATPConsStdSims, F_avgAvgSims, F_stdAvgSims, F_avgStdSims, F_stdStdSims, percFluct_FopAvgSims, percFluct_FopStdSims, FperATPConsAvgSims, FperATPConsStdSims, FperATPConsStdSims_manual];
AvgSim_PeakData = [F_opAllPeaks, F_opMovAvgPeaks, Kurt_FopAllSims, FluctPerc_FopAllSims, FluctPerc_FopAllSimsPositive, FluctPerc_perATPCons, FluctPerc_norm_F_AvgStdSims, FluctPercPositive_perATPCons, FluctPercPositive_norm_F_AvgStdSims];
AvgSim_Epot_IntSprings = [Epot_IntSprings_AvgMean_eaSim, Epot_IntSprings_StdAvgMean_acrossSims, Epot_IntSprings_AvgStd_eaSim, Epot_IntSprings_StdStd_eaSim];
AvgSim_Epot_ExtSpring = [Epot_ExtSpring_AvgMean_eaSim, Epot_ExtSpring_StdAvgMean_acrossSims, Epot_ExtSpring_AvgStd_eaSim, Epot_ExtSpring_StdStd_eaSim];
%Data for values taken over last 500*t_F_bin_s seconds (0.5 s) of each simulation
AvgSim_ATP_F_data_5 = [Fop_discr_AvgMean_eaSim, Fop_discr_StdMean_acrossSims, Fop_discr_AvgStd_eaSim, Fop_discr_StdStd_eaSim, plat_ATPConsAvgSims, plat_ATPConsStdSims, ATPase_movAvg_AvgMean_eaSim, ATPase_movAvg_StdMean_acrossSims, ATPase_movAvg_AvgStd_eaSim, ATPase_movAvg_StdStd_eaSim, FperATPConsAvgSims_5, FperATPConsStdAvgSims_5];
AvgSim_ATP_F_data_5_summary = [Fop_discr_AvgMean_eaSim, Fop_discr_StdMean_acrossSims, plat_ATPConsAvgSims, plat_ATPConsStdSims, FperATPConsAvgSims_5, FperATPConsStdAvgSims_5];
% AvgSim_PercFluct_data_5 = [FluctPerc_Fop_AvgeaSim_5, FluctPerc_Fop_StdAvg_acrossSims_5];
AvgSim_PeakData_5 = [F_opAllPeaks_5, F_opMovAvgPeaks, Fop_discr_AvgPeaks_eaSim, Fop_discr_StdPeaks_eaSim, Fop_discr_AvgKurtosis_eaSim, Fop_discr_StdKurtosis_eaSim, FluctPerc_Fop_AvgeaSim_5, FluctPerc_Fop_AvgeaSimPositive_5, FluctPercPositive_perATPCons_AvgeaSim_5];
AvgSim_PeakData_Epot_5 = [Epot_discr_AvgPeaks_eaSim, Epot_discr_StdPeaks_eaSim, Epot_discr_AvgKurtosis_eaSim, Epot_discr_StdKurtosis_eaSim, FluctPerc_Epot_AvgeaSim_5, FluctPerc_Epot_AvgeaSimPositive_5, FluctPercPositive_perATPCons_Epot_AvgeaSim_5];
% AvgSim_AboveBelow_5 = [t_ab_AvgMean, t_ab_AvgStd, t_ab_StdStd, F_ab_AvgMean, F_ab_AvgStd, F_ab_StdStd];
% AvgSim_MlineData_5 = [Mline_disp_AvgMean_eaSim, Mline_disp_AvgStd_eaSim, Mline_disp_AvgRange_eaSim, Mline_disp_StdRange_eaSim, Mline_dispPerATPConsAvgSims_5, Mline_dispPerATPConsStdSims_5];




%================================================================================================================
%% Print out data for multiple simulations
    % For SINGULAR (most recent) simulation
    fprintf('\nFor 1 simulation: \n'); 
    fprintf('Range of moving avg. ATP consumed/s = %.1f ATP/s \n', range(ATP_consumed_movingAvg));
    fprintf('Avg. of moving avg. ATP consumed/s = %.1f ATP/s \n', mean(ATP_consumed_movingAvg, 'omitnan'));
    fprintf('Variance of moving avg. ATP consumed/s = %.1f ATP^2/s \n', var(ATP_consumed_movingAvg, 'omitnan'));
    fprintf('Std. of moving avg. ATP consumed/s = %.2f ATP/s \n \n', sqrt(var(ATP_consumed_movingAvg, 'omitnan')));
    
    fprintf('Range F = %.1f pN \n', range(F_output(1:tot_timesteps-1)));
    fprintf('Avg. F = %.1f pN \n', sum(F_output(1:tot_timesteps-1).*(dt_store./t_end_true)));
    fprintf('Variance F = %.1f pN^2 \n', var(F_output(1:tot_timesteps-1), dt_store));
    fprintf('Std. F = %.1f pN \n', sqrt(var(F_output(1:tot_timesteps-1), dt_store)));
    fprintf('Percent Fluct. F = %.2f%% \n', sqrt(var(F_output(1:tot_timesteps-1), dt_store))/sum(F_output(1:tot_timesteps-1).*(dt_store./t_end_true))*100);
    fprintf('------------------------------------------ \n');
    if totalSimCounter > 1
        fprintf('For %i Total Sims: \n', totalSimCounter);
        %total ATPase activity
        fprintf('Total ATPase activity = %i ATP \n', tot_ATPase_trackerTotSims);
        fprintf('Avg. Total ATPase activity/sarc = %.1f ATP/sarc \n', avgATP_perSarc);
        fprintf('Avg. Total ATPase activity/myo = %.1f ATP/myosin \n \n', avgATP_perMyo);

        %moving average of ATP consumption/time for total simulations
        fprintf('Variance of moving avg. Total ATP consumed/s = %.1f ATP^2/s \n', var_amATPConsTotSims);
        fprintf('Std of moving avg. Total ATP consumed/s = %.1f ATP/s \n \n', sqrt(var_amATPConsTotSims));

        %average ATP consumption/total time for total simulations
        fprintf('Total ATP consumed/s = %.1f ATP/s \n', plat_ATPConsTotSims);
        fprintf('ATP consumed/s/sarc = %.1f ATP/s/sarc \n', ATPConsTotSims_perSarc);
        fprintf('ATP consumed/s/myo = %.1f ATP/s/sarc \n \n', ATPConsTotSims_perMyo);

        %Force for total simulations
        fprintf('Range Total F = %.1f pN \n', range_FopTotSims);
        fprintf('Avg. Total F = %.1f pN \n', avg_FopTotSims);
        fprintf('Avg. Total F/sarc = %.1f pN/sarc \n', avg_FopTotSims_perSarc);
        fprintf('Variance Total F = %.1f pN^2 \n', var_FopTotSims);
        fprintf('Std Total F = %.1f pN \n', std_FopTotSims);
        fprintf('Percent Fluct. Total F = %.2f%% \n', percFluct_FopTotSims);
        fprintf('Percent Fluct. Total F/sarc = %.2f%% \n', percFluct_FopTotSims_perSarc);
        
        %store in copy-paste to excel vector
        %vector order: (1) var(movAvgATPcons) (1.5) plateau_ATPConsTotSims (2) avg ATP/t/sarc (3) avg ATP/t/myo (4) avg tot ATP/sarc 
        %(5) Avg tot ATP/myo (6) Avg. Total F (7) Avg. Total F/sarc (8) std. Total F (9) % fluctuations Total F (std.F/avgF) 
        %(10) % fluctuations Total F/sarc (std.F/avgF/sarc) (11) 
        TotalSim_ATP_F_data = [var_amATPConsTotSims, plat_ATPConsTotSims, ATPConsTotSims_perSarc,  ATPConsTotSims_perMyo, avgATP_perSarc, avgATP_perMyo, avg_FopTotSims, avg_FopTotSims_perSarc, std_FopTotSims, percFluct_FopTotSims, percFluct_FopTotSims_perSarc, var_FopTotSims];
        
        
    end
    fprintf('========================================== \n');
    
        
%Store Raw Data values in Cell array
if totalSimCounter > 1
Data_Cell = {percFluct_FopTotSims; AvgSim_ATP_F_data_5; AvgSim_ATP_F_data_5_summary; AvgSim_Epot_ExtSpring; AvgSim_Epot_IntSprings; ...
    TotalSim_ATP_F_data; Fop_discr_means_eaSim; plat_ATPConsPerSim; FperATPCons_eaSim_5; Epot_ExtSpring_Mean_store; Epot_IntSprings_Mean_store};
end
Data_Cell = {percFluct_FopTotSims; AvgSim_ATP_F_data_5; AvgSim_ATP_F_data_5_summary; AvgSim_Epot_ExtSpring; AvgSim_Epot_IntSprings; ...
    Fop_discr_means_eaSim; plat_ATPConsPerSim; FperATPCons_eaSim_5; Epot_ExtSpring_Mean_store; Epot_IntSprings_Mean_store};
RawData_Matrix = [Fop_discr_means_eaSim; plat_ATPConsPerSim; FperATPCons_eaSim_5; Epot_ExtSpring_Mean_store; Epot_IntSprings_Mean_store];
        
        
    % Plot of M-line location (now moved to figure 17)
%     yyaxis right
%     plot(t.', N_locations(:, end)*(1e9), 'Color', [0.4940 0.1840 0.5560], 'Marker', '.', 'Linestyle', 'none');
%     ylabel('M-line location (nm)');
%     ylim([0, N_locations(1, end)*(1e9)+2]);
%     title('F_{output} vs. Time ft. Avg. F_{output} (g) + M-line loc. (p)');
    
    
    
% Histogram of times spent in each state for all myosin 
    figure(18)
%     state_hist_data = [sum(myo_st(1,:)), sum(myo_st(2,:)), sum(myo_st(3,:))]; %For last simulation that ran
    state_hist_data = [mean(sum(myo_st_store(1, :, :))), mean(sum(myo_st_store(2,:,:))), mean(sum(myo_st_store(3,:,:)))]; %Average of all simulations run
    if a_nodes == 1 && m_nodes == 1
        state_hist_data = [mean(myo_st_store(1, :, :)), mean(myo_st_store(2,:,:)), mean(myo_st_store(3,:,:))]; %Average of all simulations run
    end
    avg_st_hist_data = mean(avg_myo_st, 1); %state_hist_data./m_nodes; <- gives the same thing, but is only for most recent simulation n = n_sim
    
    if m_nodes ~= 2
     % If we want to see the overall presence of all myosin in each state
      if a_nodes ~= 1 && m_nodes ~= 1
        bar(state_hist_data);
        hold on
%         text(1:length(state_hist_data), state_hist_data, num2str(state_hist_data.'),'vert','bottom','horiz','center'); %Number of iterations raw
%         text(1:length(state_hist_data), state_hist_data, num2str(round(state_hist_data.'./(tot_timesteps-t_Ca), 3)),'vert','bottom','horiz','center'); %Number of iterations/total timesteps
        % Create bar labels with Raw number of iterations on line 1 and number iterations/total time 
        state_hist_data_labels = {};
        for i = 1:3
            state_hist_data_labels{i} = [num2str(state_hist_data(i))]; %, newline, num2str(round(state_hist_data(i)./(t(tot_timesteps) - t(t_Ca)), 3))]; 
        end    
        text(1:length(state_hist_data), state_hist_data, state_hist_data_labels,'vert','bottom','horiz','center');
      else  
        bar(avg_st_hist_data); %Plot average number of iterations/state for a single myosin
        % Create bar labels with Raw number of iterations on line 1 and number iterations/total time in line 2
        avg_st_hist_data_labels = {};
        for i = 1:3
            avg_st_hist_data_labels{i} = [num2str(avg_st_hist_data(i)), newline, num2str(round(avg_st_hist_data(i)./(avg_t_end_true - t(t_Ca)), 3))];
        end    
        text(1:length(avg_st_hist_data), avg_st_hist_data, avg_st_hist_data_labels,'vert','bottom','horiz','center');
      end
        %         text(1:length(avg_st_hist_data), avg_st_hist_data, num2str(round(avg_st_hist_data.'./(tot_timesteps-t_Ca), 3)),'vert','bottom','horiz','center'); %Number of iterations/total timesteps
        ylim([0, max(state_hist_data)+ max(state_hist_data)/10]);
        title(['Time spent in each state, n = ', num2str(n_sim)]); %; Sum of all myosin (b), Average/myosin (o), 
        
    else
     % If we want to see which myosin is present in each state
%         state_hist_data_indiv = reshape(myo_st, [1, numel(myo_st)]); <- gives the same thing as below, but is only for most recent simulation n = n_sim
        state_hist_data_indiv = reshape(mean(myo_st_store, 3), [1, numel(myo_st_store(:,:,1))]);
        bar([state_hist_data_indiv, avg_st_hist_data]);
        hold on
        st_hist_text = {'m1.1' , 'm1.2', 'm1.3', 'm2.1', 'm2.2', 'm2.3', 'avg1', 'avg2', 'avg3'};
        set(gca, 'XTick', 1:10, 'XTickLabel', st_hist_text);
        % Create bar labels with Raw number of TIME on line 1 and number iterations/total time in line 2
        state_hist_data_indiv_labels = {};
        for i = 1:6
            state_hist_data_indiv_labels{i} = [num2str(state_hist_data_indiv(i)), newline, num2str(round(state_hist_data_indiv(i)./(t(tot_timesteps) - t(t_Ca)), 3))]; 
        end    
        text(1:length(state_hist_data_indiv), state_hist_data_indiv, state_hist_data_indiv_labels,'vert','bottom','horiz','center');
%         text(1:length(state_hist_data_indiv), state_hist_data_indiv, num2str(round(state_hist_data_indiv.'./(tot_timesteps-t_Ca), 3)),'vert','bottom','horiz','center'); %Number of iterations/total timesteps
        % Create bar labels with Raw number of iterations on line 1 and number iterations/total time in line 2
        avg_st_hist_data_labels = {};
        for i = 1:3
            avg_st_hist_data_labels{i} = [num2str(avg_st_hist_data(i)), newline, num2str(round(avg_st_hist_data(i)./(t(tot_timesteps) - t(t_Ca)), 3))]; 
        end    
        text(length(state_hist_data_indiv)+1:length(state_hist_data_indiv)+length(avg_st_hist_data), avg_st_hist_data, avg_st_hist_data_labels,'vert','bottom','horiz','center');
%         text(length(state_hist_data_indiv)+1:length(state_hist_data_indiv)+length(avg_st_hist_data), avg_st_hist_data, num2str(round(avg_st_hist_data.'./(tot_timesteps-t_Ca), 3)),'vert','bottom','horiz','center'); %Number of iterations/total timesteps
        ylim([0, max(state_hist_data_indiv)+ max(state_hist_data_indiv)/10]);
        title(['Time spent in each state for each myosin + averages, n = ', num2str(n_sim)]);
    end
    hold on
%     ylabel(['Number of iterations (total timesteps = ', num2str(tot_timesteps-1), ')']);
    ylabel(['Time (s) (total time = ', num2str(t_end_true), ' s)']);
    xlabel('Myosin State');
end

%% Variance and Std Dev of Force

% Periodic avg. force data
Fop_periodic_dts = (t(af_period:af_period:length(t))) - (t(1:af_period:length(t)-af_period));
% avg_avg_Fop_periodic = mean(avg_F_output_periodic); %unweighted
avg_avg_Fop_periodic = sum(avg_F_output_periodic'.*(Fop_periodic_dts./t_end_true)); %weighted
% var_avg_Fop_periodic = var(avg_F_output_periodic, Fop_periodic_dts);
% std_avg_Fop_periodic = std(avg_F_output_periodic, Fop_periodic_dts);

% Raw force values
var_raw_Fop_weighted = F_var_store(1, sim_counter); %var(F_output(1:tot_timesteps-1), dt_store);
% var_raw_Fop_weighted_eq = sum((F_output(1:tot_timesteps-1)-avg_F_output).^2.*(dt_store/t_end_true));
std_raw_Fop_weighted = F_std_store(1, sim_counter); %std(F_output(1:tot_timesteps-1), dt_store);

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % if t_appforce > 0
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     t_Fext_0 = [t_Ca:t_index_appforce-1, t_index_removeforce:tot_timesteps-1];
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     t_Fext_0 = floor(t_Fext_0);
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     t_Fext_app = [t_index_appforce:1:(t_index_removeforce - 1)];
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     t_Fext_app = floor(t_Fext_app);
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     avg_raw_Fext_0 = sum(F_output(t_Fext_0).*(dt_store(t_Fext_0)/t_end_true));
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     avg_raw_Fext_app = sum(F_output(t_Fext_app).*(dt_store(t_Fext_app)/t_end_true));
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     var_raw_Fext_0 = var(F_output(t_Fext_0), dt_store(t_Fext_0));
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     var_raw_Fext_app = var(F_output(t_Fext_app), dt_store(t_Fext_app));
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %         
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     std_raw_Fext_0 = std(F_output(t_Fext_0), dt_store(t_Fext_0));
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %     std_raw_Fext_app = std(F_output(t_Fext_app), dt_store(t_Fext_app));
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % end
%fprintf('Periodic Avg. Force Mean = %f pN \n', avg_avg_Fop_periodic); %only applies to most recent simulation
%fprintf('Periodic Avg. Force Variance = %f pN \n', var_avg_Fop_periodic); %only applies to most recent simulation
%fprintf('Periodic Avg. Force StdDev = %f pN \n', std_avg_Fop_periodic); %only applies to most recent simulation

fprintf('For the most recent simulation: \n');
fprintf('Raw Force Mean = %f pN \n', avg_F_output); %only applies to most recent simulation

    fprintf('Raw Force Variance = %f pN^2 \n', var_raw_Fop_weighted); %only applies to most recent simulation
    fprintf('Raw Force StdDev = %f pN \n', std_raw_Fop_weighted); %only applies to most recent simulation

fprintf('_______________________________________________________________ \n');
fprintf('=============================================================== \n');

% Plot M-line locations alone
    figure(17)
    plot(N_locations(:, end)*(1e9), t.', 'Color', [0.4940 0.1840 0.5560], 'Marker', '.', 'Linestyle', 'none');
%     plot(N_locations(530:560, end)*(1e9), t(1, 530:560).', 'Color', [0.4940 0.1840 0.5560], 'Marker', '.', 'MarkerSize', 10, 'Linestyle', '--', 'LineWidth', 1);
    hold on 
    ylabel('Time (s)');
    xlabel('M-line location (nm)');
    title('M-line location (nm) vs. Time (s)');
    
% Plot the ditribution of the values of dt
%     n_dt = max(log10(dt_store)) - min(log10(dt_store))+1; %for variable dt at intervals of orders of 10
%     figure(19)
%     h = histogram(log10(dt_store), n_dt); %creates number of bins equivalent to each value of dt having its own bin
%     hold on
%     h.BinWidth = 1;
%     h.BinLimits = [min(log10(dt_store))-0.5, max(log10(dt_store))+0.5];
%     text(min(log10(dt_store)):max(log10(dt_store)), h.Values, string(h.Values), 'vert', 'bottom', 'horiz', 'center');
%     xticks(linspace(min(log10(dt_store)), max(log10(dt_store)), n_dt));
%     xlabel('log_{10}dt  (log_{10}s)');
%     ylabel('Iterations');
%     title('Distribution of Values of Timestep');
    
    %for exact values of dt to cause probabilities to sum to prob_summed_max_exact
    figure(19)
%     h = histogram(dt_store); %creates number of bins equivalent to each value of dt having its own bin
    bar(log10(dt_store_unique(:,1)), dt_store_unique(:,2));
    hold on
%     dt_plot_labels = [repmat('(', length(dt_store_unique(:,1)), 1), num2str(dt_store_unique(:,1), '%.2e'), repmat(', ', length(dt_store_unique(:,1)), 1), num2str(dt_store_unique(:,2)), repmat(')', length(dt_store_unique(:,1)), 1)];
    dt_plot_labels = [repmat('(', length(dt_store_unique(:,1)), 1), num2str(dt_store_unique(:,1), '%.2e'), repmat(')', length(dt_store_unique(:,1)), 1)];
    text(log10(dt_store_unique(:,1)), dt_store_unique(:,2), dt_plot_labels,'vert','bottom','horiz','center');
%     h.BinWidth = 1;
%     h.BinLimits = [min(dt_store)-0.5, max(dt_store)+0.5];
%     text(min(dt_store):max(dt_store), h.Values, string(h.Values), 'vert', 'bottom', 'horiz', 'center');
%     xticks(linspace(min(log10(dt_store)), max(log10(dt_store)), n_dt));
    xlabel('Duration (log_{10}(s))');
    ylabel('Iterations');
    xlim([min(log10(dt_store_unique(:,1)))-0.5, max(log10(dt_store_unique(:,1)))+0.5]);
    title('Distribution of Values of Timestep'); 
 
    %Plot Power, should only be positive when M-line is departing from rest length, either contraction or stretching
%{
    figure(20)
    yyaxis left
    plot(t(t_index), work_store(t_index, 1)*1e7/dt, '-gp');
%     plot(t(t_index), sum(work_store(:, 1))*1e7, 'ks');
    ylabel('Power (J/ms)');
    hold on
    yyaxis right
%     plot(t(t_index), N_locations(t_index+1, end)*(1e9), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%     ylabel('M-line location (nm)');
    plot(t(t_index), F_output(1, t_index), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
    ylabel('F_{output} (pN)');
    %plot(t(t_index), sum(ATPase_tracker(1, :)), '-bo');
    xlabel('Time (s)');
%     ylabel('Work (J)');
    %title('Work (red) & Cumulative Work (black) vs. Time');
    title('Power (green) and F_{output} vs. Time');
%}   

% end    %remove when done with t_cycle graphs
% Plot histogram of unique t_cycle values
%section below commented out 10/19/2021, can bring back when need
%{
    figure(22)
    bar(t_cycle_unique(:,1), t_cycle_unique(:,2));
    hold on
    t_cycle_plot_labels = [repmat('(', length(t_cycle_unique(:,1)), 1), num2str(t_cycle_unique(:,1), '%.1f'), repmat(',', length(t_cycle_unique(:,1)), 1), num2str(t_cycle_unique(:,2), '%i'), repmat(')', length(t_cycle_unique(:,1)), 1)];
    text(t_cycle_unique(:,1), t_cycle_unique(:,2), t_cycle_plot_labels,'vert','bottom','horiz','center' , 'FontSize', 8);
    hold on
    xline(t_cycle_avg*1e3, '-', {'Avg.', num2str(round(avg_t_cycle_avg*1e3, 2))});
    xline(t_cycle_median*1e3, '-', {'Median', num2str(round(avg_t_cycle_median*1e3, 2))});
    xlabel('Duration (ms)');
    ylabel('Iterations');
    title(['Distribution of Time of One Cross-bridge Cycle']); %; ADP factor = ', num2str(conc_factor, '%2e')]); 
%}
    
    %Plot displacements for transitions for t = t_index! NOT t_index+1
%{
    figure(1310)
    yyaxis right
    ylabel('m4 or m5');
    hold on
    %Plot only state 3
%     if N_states(t_index+1, a_nodes+2) == 3 %plot m1
%         plot(xb_conn_comb(3,((a_nodes+2)-(a_nodes+1)))*(1e9), 0, colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%     end
%     hold on
%     if N_states(t_index+1, tot_nodes-1) == 3 %plot m2
%         plot(xb_conn_comb(3,((tot_nodes-1)-(a_nodes+1)))*(1e9), 1, colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%     end
    %Plot all states
    if t_Ca_counter > t_Ca
%         if xb_conn_comb(3, 1) < -5*(1e-9) && N_states(t_index, 4) == 1 && N_states(t_index, 5) == 1 
%             disp('fishy');
%             disp(t_index);
%             pause
%         end
%         if N_states(t_index+1, 4) == 3
%             plot((xb_conn_comb(3,1)+d_ps)*(1e9), 1+0.1*N_states(t_index+1, 4), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%         else
            plot(xb_conn_comb(3,1)*(1e9), 4+0.1*N_states(t_index, 4), colorcode{N_states(t_index, a_nodes+2), N_states(t_index, a_nodes+3)});
%         end
            hold on
%         if N_states(t_index+1, 5) == 3
%             plot((xb_conn_comb(3,2)+d_ps)*(1e9), 2+0.1*N_states(t_index+1, 5), colorcode{N_states(t_index+1, a_nodes+2), N_states(t_index+1, a_nodes+3)});
%         else
            plot(xb_conn_comb(3,2)*(1e9), 5+0.1*N_states(t_index, 5), colorcode{N_states(t_index, a_nodes+2), N_states(t_index, a_nodes+3)});
%         end
    end
    ylim([3.9, 5.8]);
    
    figure(13102)
     yyaxis right
    ylabel('m4 or m5');
    hold on
    %Plot all states
    if t_Ca_counter > t_Ca
        plot((xb_conn_comb(3,1)+xb0)*(1e9), 4+0.1*N_states(t_index, 4), colorcode{N_states(t_index, a_nodes+2), N_states(t_index, a_nodes+3)});
        hold on
        plot((xb_conn_comb(3,2)+xb0)*(1e9), 5+0.1*N_states(t_index, 5), colorcode{N_states(t_index, a_nodes+2), N_states(t_index, a_nodes+3)});
    end
    ylim([3.9, 5.8]);
%}    
    
    %Plot Transition Pathways Movie
%     m_states = N_states(:, a_nodes+2:tot_nodes-1);
    %{
    figure(45)
    ylabel('myosin 2 state');
    xlabel('myosin 1 state');
    ylim([0, 4]);
    xlim([0, 4]);
    title('Transition Pathways of Myosins 1 and 2');
    hold on
    for tt = 2:tot_timesteps-1
        figure(45)
%         if sum(xb_trans_store(tt, :))~=0
        plot(m_states(tt-1:tt, 1), m_states(tt-1:tt, 2), '-ro', 'LineWidth', 2.0); %tt/10);
        hold on
        plot(m_states(tt:tt+1, 1), m_states(tt:tt+1, 2), '-k', 'LineWidth', 2.0);
        hold on
        plot(m_states(tt, 1), m_states(tt, 2), 'ko', 'LineWidth', 2.0);
        hold on
        plot(m_states(tt+1, 1), m_states(tt+1, 2), 'go', 'LineWidth', 2.0);
        hold on
        drawnow();
        disp(tt);
        pause(0.25)
%         end
    end
%     plot(m_states(:,1), m_states(:,2), '-b.');
    
    %}
    
%end

%__________________________________________________________________________

% %Plot ATPase vs. time
% figure('Name','ATPase vs. time');
% scatter(1:tot_timesteps, ATPase_tracker, 10, 'filled');
% hold on
% xlabel('Time (us)'); %?s
% ylabel('Cumulative ATP hydrolyzed');
% hold off
% % 
% %Plot F_output vs. time
% figure('Name','F_output vs. time');
% scatter(1:tot_timesteps, F_output, 10, 'filled');
% hold on
% xlabel('Time (us)'); %?s
% ylabel('Force Exerted (N)');
% hold off
% 
% %Plot strain_hs vs. time
% figure('Name','Strain on HS vs. time');
% scatter(1:tot_timesteps, strain_hs, 10, 'filled');
% hold on
% xlabel('Time (us)'); %?s
% ylabel('Strain');
% hold off

%Plot mM vs. time
% figure('Name','mM vs. time');
% scatter(1:tot_timesteps, N_locations(:, end)*(1e9), 10, 'filled');
% hold on
% xlabel('Time (us)'); %?s
% ylabel('nm');
% hold off

end %bring back when done with cycle time graphs (t_cycle)

% fprintf('_______________________________________________________________ \n');
% fprintf('_______________________________________________________________ \n');
fprintf('=============================================================== \n');

% fprintf('kF = %.1e N/m \nt = %.1f s \n prob_sum_max_exact = %.2f \nAvg. Force = %.3f pN \nATP/time = %.1f ATP/s \nDuty Ratio = %.4f \n', kF, avg_t_end_true, ...
%     prob_summ_max_exact, avg_avg_F_output, avg_ATP_per_time, avg_duty_ratio);
fprintf('For n = %i \n', n_sim);
fprintf('kF = %.1e N/m \nt = %.1f s \nprob_sum_max_exact = %.2f \nAvg. Force = %.3f pN \nPeak Force = %.3f pN \nATP/time = %.1f ATP/s \nDuty Ratio = %.4f \n', kF, avg_t_end_true, ...
    prob_sum_max_exact, avg_avg_F_output, max(F_output), avg_ATP_per_time, avg_duty_ratio);
fprintf('Avg. Cycle Time = %.5f s\n', avg_t_cycle_avg);
% fprintf('Avg. Force Var. = %.3f pN^2 \nAvg. Force Std. Dev. = %.3f pN \n', avg_F_var, avg_F_std);
% fprintf('Fvar_n2pk = %.3f pN^2 \nFvar_n2avg = %.3f pN^2\n', avg_F_var_Norm2Peak, avg_F_var_Norm2Avg);
fprintf('=============================================================== \n');

%% Save Workspace?
wsname = ['testcase=', num2str(testcase), '_', ...
            'totalsims=', num2str(totalSimCounter), '_', ...
            'a_nodes=', num2str(a_nodes), '_', ...
            'm_nodes=', num2str(m_nodes), '_', ...
            't_end_true=', num2str(t_end_true), '_', ...
            'conc_ADP', num2str(conc_ADP), '_', ...
            'conc_ATP', num2str(conc_ATP), '_', ...
            'date=', datestr(now, 'mm-dd-yy-HH-MM'), '.mat']; %, 'DATA_FOR_3D_ATPADP_PLOTS.mat'];
if save_workspace
    save(wsname);
end

%% Functions to Generate Parameter and Output Variables
%{
%% Parameter 1 Variable Generation
%This function generates all the necessary parameter variables for exploring parameter 1
%pass this function p1 (i.e. the string name of the parameter to be explored) and explore = true or false depending on
%whether you are exploring the parameter or not, or if it should be locked at its original value created in constgen.m
function [parameter_1_label, parameter_1_initial, parameter_1_xlim, pe1_end, parame1_update_plot, parameter_1_update] = parameter_1_func(name, explore, consts)
kB = consts(1);
T = consts(2);
dG_c = consts(3);
dG_bind = consts(4);
dG_stroke = consts(5);
kATP0 = consts(6);
k23_cap = consts(7);
kbind = consts(8);

    switch name
        case 'dG_c'
            parameter_1_label = 'dG_c (kBT)';
            parameter_1_initial = -20*kB*T; %in const_gen normally -12 other: -15 -20
            pe1_end = 16; %24; %12; %40; %20 25;
            pe1_increment = 0.75*kB*T;
            parameter_1_xlim = [-25, -5];
            parame1_update_plot = 1/(kB*T).*[parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            parameter_1_update = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            %linspace(parameter_1_initial, parameter_1_final, pe1_end);
        case 'dG_bind'
            parameter_1_label = 'dG_{bind} (kBT)';
            parameter_1_initial = -7*kB*T; %-5.5*kB*T;
            pe1_end = 20;
            pe1_increment = 0.5*kB*T;
            parameter_1_xlim = [-10, 5];
            parame1_update_plot = 1/(kB*T).*[parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            parameter_1_update = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
        case 'dG_stroke'
            parameter_1_label = 'dG_{stroke} (kBT)';
            parameter_1_initial = -18*kB*T; %in const_gen normally -12 other: -15 -20
            pe1_end = 20;
            pe1_increment = 1*kB*T;
            parameter_1_xlim = [-20, 5];
            parame1_update_plot = 1/(kB*T).*[parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            parameter_1_update = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
        case 'kATP0'
            parameter_1_label = 'k{ATP,0} (s^{-1})';
            parameter_1_initial = 1e-4; %in const_gen normally 1e-2 or 1e-3
            pe1_end = 20;
            pe1_increment = 7e-3;
            parameter_1_xlim = [5e-5, 0.2];
            parame1_update_plot = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            parameter_1_update = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
        case 'k23_cap'
            parameter_1_label = 'k{23cap} (s^{-1})';
            parameter_1_initial = 50; %in const_gen normally 800
            pe1_end = 20;
            pe1_increment = 50;
            parameter_1_xlim = [0, 1000];
            parame1_update_plot = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            parameter_1_update = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
        case 'kbind'
            parameter_1_label = 'k{bind} (s^{-1})';
            parameter_1_initial = 50; %in const_gen normally 1e-2 or 1e-3
            pe1_end = 20;
            pe1_increment = 50;
            parameter_1_xlim = [0, 1000];
            parame1_update_plot = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
            parameter_1_update = [parameter_1_initial:pe1_increment: (parameter_1_initial + pe1_increment*(pe1_end-1))];
    
    end
    
    if explore == false %Not exploring i.e. Only doing 1 iteration using whatever parameter values are presented in the originally selected .mat file created by constgen.m
        
        switch name
            case 'dG_c'
                parameter_1_initial = dG_c;
            case 'dG_bind'
                parameter_1_initial = dG_bind;
            case 'dG_stroke'
                parameter_1_initial = dG_stroke;
            case 'kATP0'
                parameter_1_initial = kATP0;
            case 'k23_cap'
                parameter_1_initial = k23_cap;
            case 'kbind'
                parameter_1_initial = kbind;
        end
        parameter_1_update = parameter_1_initial.*ones(1, (pe1_end-1));
        pe1_end = 2;
    end
end

%This function will re-initialize the explored parameter 1 at the beginning of each simulation loop
%pass this function p1
function parame1_initialize(name, parameter_1_initial)
    switch name
        case 'dG_c'
            assignin('base', 'dG_c', parameter_1_initial);
        case 'dG_bind'
            assignin('base', 'dG_bind', parameter_1_initial);
        case 'dG_stroke'
            assignin('base', 'dG_stroke', parameter_1_initial);
        case 'kATP0'
            assignin('base', 'kATP0', parameter_1_initial);
        case 'k23_cap'
            assignin('base', 'k23_cap', parameter_1_initial);
        case 'kbind'
            assignin('base', 'kbind', parameter_1_initial);
            
    end
end
        

%This function updates the value of the parameter 1 that is being explored at the end of the parameter 1 exploration loop
%pass this function p1
function parame1_updater(name)
    switch name
        case 'dG_c'
            evalin('base', 'dG_c = parameter_1_update(pe_counter1);');
        case 'dG_bind'
            evalin('base', 'dG_bind = parameter_1_update(pe_counter1);');
        case 'dG_stroke'
            evalin('base', 'dG_stroke = parameter_1_update(pe_counter1);');
        case 'kATP0'
            evalin('base', 'kATP0 = parameter_1_update(pe_counter1);');
        case 'k23_cap'
            evalin('base', 'k23_cap = parameter_1_update(pe_counter1);');
        case 'kbind'
            evalin('base', 'kbind = parameter_1_update(pe_counter1);');
    end
end


%% Parameter 2 Variable Generation

%This function generates all the necessary parameter variables for exploring parameter 2
%pass this function p2 (i.e. the string name of the parameter to be explored) and explore = true or false depending on
%whether you are exploring the parameter or not, or if it should be locked at its original value created in constgen.m
function [parameter_2_label, parameter_2_initial, parameter_2_ylim, pe2_end, parame2_update_plot, parameter_2_update] = parameter_2_func(name, explore, consts)
kB = consts(1);
T = consts(2);
dG_c = consts(3);
dG_bind = consts(4);
dG_stroke = consts(5);
kATP0 = consts(6);
k23_cap = consts(7);
kbind = consts(8);

    switch name
        case 'dG_c'
            parameter_2_label = 'dG_c (kBT)';
            parameter_2_initial = -20*kB*T; %in const_gen normally -12 other: -15 -20
            pe2_end = 16; %24; %12; %40; %20 25;
            pe2_increment = 0.75*kB*T;
            parameter_2_ylim = [-25, -5];
            parame2_update_plot = 1/(kB*T).*[parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            parameter_2_update = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            %linspace(parameter_1_initial, parameter_1_final, pe1_end);
        case 'dG_bind'
            parameter_2_label = 'dG_{bind} (kBT)';
            parameter_2_initial = -7*kB*T; %-5.5*kB*T;
            pe2_end = 20;
            pe2_increment = 0.5*kB*T;
            parameter_2_ylim = [-10, 5];
            parame2_update_plot = 1/(kB*T).*[parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            parameter_2_update = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
        case 'dG_stroke'
            parameter_2_label = 'dG_{stroke} (kBT)';
            parameter_2_initial = -18*kB*T; %in const_gen normally -12 other: -15 -20
            pe2_end = 20;
            pe2_increment = 1*kB*T;
            parameter_2_ylim = [-20, 5];
            parame2_update_plot = 1/(kB*T).*[parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            parameter_2_update = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
        case 'kATP0'
            parameter_2_label = 'k{ATP,0} (s^{-1})';
            parameter_2_initial = 1e-4; %in const_gen normally 1e-2 or 1e-3
            pe2_end = 20; 
            pe2_increment = 7e-3;
            parameter_2_ylim = [5e-5, 0.2];
            parame2_update_plot = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            parameter_2_update = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
        case 'k23_cap'
            parameter_2_label = 'k{23cap} (s^{-1})';
            parameter_2_initial = 50; %in const_gen normally 800
            pe2_end = 20;
            pe2_increment = 50;
            parameter_2_ylim = [0, 1000];
            parame2_update_plot = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            parameter_2_update = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
        case 'kbind'
            parameter_2_label = 'k{bind} (s^{-1})';
            parameter_2_initial = 50; %in const_gen normally 1e-2 or 1e-3
            pe2_end = 20;
            pe2_increment = 50;
            parameter_2_ylim = [0, 1000];
            parame2_update_plot = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
            parameter_2_update = [parameter_2_initial:pe2_increment: (parameter_2_initial + pe2_increment*(pe2_end-1))];
    end
    
    if explore == false %Not exploring i.e. Only doing 1 iteration using whatever parameter values are presented in the originally selected .mat file created by constgen.m
        
        switch name
            case 'dG_c'
                parameter_2_initial = dG_c;
            case 'dG_bind'
                parameter_2_initial = dG_bind;
            case 'dG_stroke'
                parameter_2_initial = dG_stroke;
            case 'kATP0'
                parameter_2_initial = kATP0;
            case 'k23_cap'
                parameter_2_initial = k23_cap;
            case 'kbind'
                parameter_2_initial = kbind;
        end
        parameter_2_update = parameter_2_initial.*ones(1, (pe2_end-1));
        pe2_end = 2;
    else
%         switch name
%             case 'dG_c'
%                 assignin('base', 'dG_c', parameter_2_initial);
%             case 'dG_bind'
%                 assignin('base', 'dG_bind', parameter_2_initial);
%             case 'dG_stroke'
%                 assignin('base', 'dG_stroke', parameter_2_initial);
%             case 'kATP0'
%                 assignin('base', 'kATP0', parameter_2_initial);
%                 
%         end
    end      
end

%This function will re-initialize the explored parameter 2 at the beginning of each parameter 1 exploration loop
%pass this function p2
function parame2_initialize(name, parameter_2_initial)
    switch name
        case 'dG_c'
            assignin('base', 'dG_c', parameter_2_initial);
        case 'dG_bind'
            assignin('base', 'dG_bind', parameter_2_initial);
        case 'dG_stroke'
            assignin('base', 'dG_stroke', parameter_2_initial);
        case 'kATP0'
            assignin('base', 'kATP0', parameter_2_initial);
        case 'k23_cap'
            assignin('base', 'k23_cap', parameter_2_initial);
        case 'kbind'
            assignin('base', 'kbind', parameter_2_initial);
    end
end

%This function updates the value of the parameter 2 that is being explored at the end of the parameter 2 exploration loop
%pass this function p2 and pe2_counter
function parame2_updater(name)
    switch name
        case 'dG_c'
            evalin('base', 'dG_c = parameter_2_update(pe_counter2);');
        case 'dG_bind'
            evalin('base', 'dG_bind = parameter_2_update(pe_counter2);');
        case 'dG_stroke'
            evalin('base', 'dG_stroke = parameter_2_update(pe_counter2);');
        case 'kATP0'
            evalin('base', 'kATP0 = parameter_2_update(pe_counter2);');
        case 'k23_cap'
            evalin('base', 'k23_cap = parameter_2_update(pe_counter2);');
        case 'kbind'
            evalin('base', 'kbind = parameter_2_update(pe_counter2);');
    end
end

%% Output Variable Generation and Update

function output_func(op)
    switch op
        case 'duty_ratio'
            evalin('base', 'outpute = duty_ratio;');
            assignin('base', 'outputname', 'duty ratio');
            assignin('base', 'output_zlim', [0, 1]);
        case 'avg_F_output'
            evalin('base', 'outpute = avg_F_output;');
            assignin('base', 'outputname', 'Avg F_{output} (pN)');
            assignin('base', 'output_zlim', [-1, 5]);
    end
end

%}