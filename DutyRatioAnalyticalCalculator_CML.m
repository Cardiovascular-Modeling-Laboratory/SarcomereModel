%{
DutyRatioAnalyticalCalculator_CML.m

Last Updated: 05/09/2023

written by Andrew Schmidt
Cardiomyocyte Laboratory
Henry Samueli School of Engineering
University of California, Irvine, Irvine, CA 92697

The purpose of this code is to calculate the analytical value of the duty 
ratio based on the rate constants and given ATP, ADP, and Pi 
concentrations.


Input: 
        Automatic input of:
        1. 
        
Output: Force borne through the half-sarcomere, ATPase rate

%}
%The purpose of this code is to calculate the analytical value of the duty
%ratio based on the rate constants and given ATP, ADP, and Pi
%concentrations.



%% .MAT File Opener - Open up a file of constants from which to calculate Duty Ratio values
%%{
clear all
close all
[fileName,filePath] = uigetfile('*', 'Select data file', '.');
if filePath==0
    error('None selected!');
end
load(fullfile(filePath,fileName))
%}

%% Optional: Adjust Model Parameters/Constants Manually:
%clear all
%%{
%Define spring constants
km = 6060e-3;  %spring constant for myosin filament; 6060 pN/nm in N/m
ka = 5230e-3; %spring constant for actin filament; 5230 pN/nm in N/m
kxb = 3e-3;  %spring constant for XB; 3 pN/nm in N/m
k_titin = 10e-3; %spring constant for titin; 10 pN/nm in N/m
kF = 0.5e-3; %spring constant of external force spring (representing PDMS); 0.5 pN/nm in N/m

%initial geometry constants
xb0 = 10e-9; %10 nm in m
d_ps = 7e-9; %7 nm in m

%Define rate constants' constants for state transitions 
T = 300; %in K
kB = 1.380649e-23; %in J/K
B = 1/(kB*T); %1/kBT in J^-1 (=2.4143e+20)
dG_bind = -4*kB*T; %in J
dG_stroke = -4.5*kB*T; %in J
dG_hyd_st = 13*kB*T; %in J
dG_c = -14*kB*T; %the energy associated with dissociation of ADP and Pi from actomyosin during power stroke


% Define normalization concentrations
ATP_norm = 1; %in M
ADP_norm = 1; %in M
P_norm = 1; %in M
dG_hyd = kB*T*log((ATP_norm)/((P_norm)*(ADP_norm))) + dG_hyd_st; %in J
norm_by = '1M'; 
conc_ADP_actual = 0.03e-3; %in M
conc_P_actual = 3e-3; %in M
conc_ATP_actual = 5e-3; %in M
conc_ADP = conc_ADP_actual/ADP_norm;
conc_P = conc_P_actual/P_norm; 
conc_ATP = conc_ATP_actual/ATP_norm;

kbind = 800; %in s^-1, determines rate of binding when there is no cross bridge deformation i.e. when actin and myosin xb head are perfectly aligned [state 1->2]
k23_cap = 300; %in s^-1, rate of power stroke when there is no cross bridge deformation [state 2->3]
kATP0 = 1e-2; %in s^-1, rate of reverse hydrolysis and ATP dissociation from myosin cross bridge [state 1->3]
%}

%% ATP, ADP, Pi Concentrations to calculate Duty Ratio at

ATP = [5.00E-12	5.00E-11	5.00E-10	5.00E-09	5.00E-08 5.00E-07 5.00E-06	5.00E-05	5.00E-04	5.00E-03 5.00E-02	5.00E-01 5.00E+00	5.00E+01	5.00E+02]; %in M; 
logATP = log10(ATP);

ADP = [3.00E-06	3.00E-05	3.00E-04	3.00E-03	3.00E-02	3.00E-01	3.00E+00	3.00E+01	3.00E+02	3.00E+03	3.00E+04	3.00E+05	3.00E+06	3.00E+07	3.00E+08	3.00E+09]; %in M; 
ADPPi = ADP.*conc_P; %[Pi] is held constant at 3mM
logADPPi = log10(ADPPi);

%Standard Condtions?
stdcond = false; %If this is true, then instead of calculating the duty ratio at all
                 %combinations of [ATP] and [ADP][Pi], the code will calculate duty ratio 
                 %at only the standard conditions
if stdcond == true
    ADP = 0.03e-3;
    ATP = 5e-3;
    ADPPi = ADP.*(3e-3);
end

[y_ADPPi, x_ATP] = meshgrid(ADPPi, ATP);
z_ATPoverADPPi = x_ATP./y_ADPPi;

%log of the above vectors
log_z_ADPPiATP = log10(z_ATPoverADPPi);
log_y_ADPPiATP = log10(y_ADPPi);
log_x_ADPPiATP = log10(x_ATP);

conc_i_D_end = length(ADPPi); 
conc_i_T_end = length(ATP);

conc_ADP_vec = ADP;
conc_ATP_vec = ATP; 
conc_ADPPi_vec = ADPPi;

TvD_AnalyticalDR_store = NaN(conc_i_T_end, conc_i_D_end, 5); 

peakF = 3; %3pN is the max force generated by a cross bridge in a one-myosin system 
           %under standard spring constants during simulation

% Displacement of XB
B = 1/(kB*T);
%Define displacement xm-xa-b0 during state 1 state 2 and state 3 rate calculations
x1 = 0;
x2 = 0;
x3 = (xb0-d_ps)-xb0+1e-9; %Addition of 1e-9 is because under simulation, the one-myosin system slides a distance of 6 nm because
                     %the cross-bridge is pulling against other springs within the system. The unloaded conformational change
                     %is d_ps (7 nMm). The 6 nm sliding distance was determined from simulations

% Calculate DR at each combination of ATP vs. ADPPi
cf_ADP = 1;
cf_ATP = 1;
for cf_ADP = 1:conc_i_D_end
for cf_ATP = 1:conc_i_T_end

% Rate Constant Equations

% State 1 <--> State 2
    K12 = exp(-B*(0.5*kxb*(x1)^2+dG_bind));
    k12 = kbind*exp(-B*0.25*kxb*(x1)^2);
    k21 = k12/K12;

    % State 2 <--> State 3
    K23 = exp(-B*(dG_stroke - dG_c + (0.5*kxb*(2*x3*d_ps+d_ps^2))+1/B*log(ADP(cf_ADP)*conc_P)));
    k23 = k23_cap;
    k32 = k23/K23;

    % State 3 <--> State 1
    K31 = exp(B*(dG_bind + dG_stroke + dG_hyd - dG_c + 0.5*kxb*(x3+d_ps)^2+1/B*log(ATP(cf_ATP))));
    k13 = kATP0;
    k31 = K31*k13;
    
    % Numerators
    P1_num = k23*k31 + k21*(k32 + k31);
    P2_num = k31*k12 + k32*(k12 + k13);
    P3_num = k12*k23 + k13*(k21 + k23);
    
    % Duty ratio
    DR3 = P3_num / (P3_num + P2_num + P1_num); %Duty Ratio
    DR2 = P2_num / (P3_num + P2_num + P1_num); %Percentage of cycle spent in state 2
    DR1 = P1_num / (P3_num + P2_num + P1_num); %Percentage of cycle spent in state 1
    
    TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 1) = DR1;
    TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 2) = DR2;
    TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 3) = DR3; %Duty Ratio in state 3
    TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 4) = k31*DR3 - k13*DR1; %Analytical value for ATP consumption
    TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 5) = DR3*peakF; %Analytical value for average force output
    TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 6)  = TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 5)/TvD_AnalyticalDR_store(cf_ATP, cf_ADP, 4); %Efficiency
    
    
end
end


%% Plotting
close all
TvD_x_plot = log10(conc_ATP_vec);
TvD_y_plot = log10(conc_ADPPi_vec);
x_range = [1:conc_i_T_end];
y_range = [1:conc_i_D_end];
TvD_x = TvD_x_plot(x_range);
TvD_y = TvD_y_plot(y_range);

% Create mesh of X,Y coordinates for plot
[Y, X] = meshgrid(TvD_y, TvD_x); %Concentrations in log10 M
% Y = 10.^(Y);
% X = 10.^(X);

%Create Z-axis values for the output Duty Ratio
Z_DutyRatio = TvD_AnalyticalDR_store(x_range,y_range, 3); %Duty Ratio
Z_ATPperS = TvD_AnalyticalDR_store(x_range,y_range, 4); %ATP/s
Z_AvgF = TvD_AnalyticalDR_store(x_range,y_range, 5); %mean force in pN
Z_Effic = TvD_AnalyticalDR_store(x_range,y_range, 6); %pN/(ATP/s)

%Plot Duty Ratio
figure(1)
s = surf(X, Y, Z_DutyRatio); %, 'FaceColor', 'interp'); 
hold on
%s.EdgeColor = 'none';
xlabel('log([ATP]) M');
ylabel('log([ADP*Pi]) M^2');
zlabel('Duty Ratio');
cb = colorbar;
cb.Label.String = 'Duty Ratio';
colormap(turbo);
caxis([0, 1]);
title(['[ATP] vs. [ADP][Pi] vs. Analytical Duty Ratio']);
% title(['[ATP] vs. [ADP][Pi] vs. Analytical DR where d_{ps} = 6nm']);
xlabs = xticklabels;
xlabs = string(xlabs);
xlabsnum = cellfun(@str2num, xlabs);
XTickLabels = cellstr(num2str(xlabsnum(:), '10^{%d}'));
xticklabels(XTickLabels);
ylabs = yticklabels;
ylabs = string(ylabs);
ylabsnum = cellfun(@str2num, ylabs);
YTickLabels = cellstr(num2str(ylabsnum(:), '10^{%d}'));
yticklabels(YTickLabels);
xlabel('[ATP] M');
ylabel('[ADP]*[Pi] M^2');

%Plot ATP consumption rate
figure(2)
s = surf(X, Y, Z_ATPperS); %, 'FaceColor', 'interp');
hold on
%s.EdgeColor = 'none';
xlabel('log([ATP]) M');
ylabel('log([ADP*Pi]) M^2');
zlabel('ATP/s');
cb = colorbar;
cb.Label.String = 'ATP/s';
% colormap(turbo);
title(['[ATP] vs. [ADP][Pi] vs. Analytical ATP/s']);
% title(['[ATP] vs. [ADP][Pi] vs. Analytical ATP/s where d_{ps} = 6nm']);

%Plot Average Force
figure(3)
s = surf(X, Y, Z_AvgF); %, 'FaceColor', 'interp');
hold on
% s.EdgeColor = 'none';
xlabel('log([ATP]) M');
ylabel('log([ADP*Pi]) M^2');
zlabel('ATP/s');
cb = colorbar;
cb.Label.String = 'Avg. F (pN)';
colormap(turbo);
title(['[ATP] vs. [ADP][Pi] vs. Analytical Avg. F (pN)']);
% title(['[ATP] vs. [ADP][Pi] vs. Analytical Avg. F (pN) where d_{ps} = 6nm']);

%Plot Efficiency (Tension cost)
figure(4)
s = surf(X, Y, Z_Effic); %, 'FaceColor', 'interp');
hold on
%s.EdgeColor = 'none';
xlabel('log([ATP]) M');
ylabel('log([ADP*Pi]) M^2');
zlabel('ATP/s');
cb = colorbar;
cb.Label.String = 'F/(ATP/s) (pN/(ATP/s))';
colormap(turbo);
caxis([0, 1e-3]);
title(['[ATP] vs. [ADP][Pi] vs. Analytical F/(ATP/s)']);
% title(['[ATP] vs. [ADP][Pi] vs. Analytical F/(ATP/s) where d_{ps} = 6nm']);

